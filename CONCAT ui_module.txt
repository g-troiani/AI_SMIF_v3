# Module: ui_module

# File: components/ui_module/__init__.py
# Type: py



# File: components/ui_module/app.py
# Type: py



# File: components/ui_module/config.py
# Type: py

# components/utils/config.py

import os

# Define the directory where reports will be saved
REPORT_DIRECTORY = os.path.join(os.path.dirname(__file__), 'reports')

# Define the default report format
DEFAULT_REPORT_FORMAT = 'html'

# File: components/ui_module/forms.py
# Type: py



# File: components/ui_module/routes.py
# Type: py



# File: components/ui_module/socketio_events.py
# Type: py



<!-- File: components/ui_module/frontend/index.html -->
<!-- Type: html -->

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <link rel="icon" type="image/jpg" href="/favicon.jpg">
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <link rel="icon" type="image/png" href="/favicon.png">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AI SMIF V2 Trading System</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

// File: components/ui_module/frontend/package.json
// Type: json

{
  "name": "ai-smif-v2",
  "private": true,
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "start:all": "concurrently \"cd ../../../ && python main.py\" \"cd ../backend && python app.py\" \"npm run dev\"",
    "build": "tsc && vite build",
    "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "preview": "vite preview"
  },
  "dependencies": {
    "@heroicons/react": "^2.0.18",
    "@tailwindcss/forms": "^0.5.7",
    "axios": "^1.6.2",
    "chart.js": "^4.4.0",
    "lucide-react": "^0.464.0",
    "react": "^18.2.0",
    "react-chartjs-2": "^5.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.20.0",
    "socket.io-client": "^4.7.2"
  },
  "devDependencies": {
    "@types/node": "^20.9.3",
    "@types/react": "^18.2.37",
    "@types/react-dom": "^18.2.15",
    "@typescript-eslint/eslint-plugin": "^6.10.0",
    "@typescript-eslint/parser": "^6.10.0",
    "@vitejs/plugin-react": "^4.2.0",
    "autoprefixer": "^10.4.16",
    "concurrently": "^9.1.0",
    "eslint": "^8.53.0",
    "eslint-plugin-react-hooks": "^4.6.0",
    "eslint-plugin-react-refresh": "^0.4.4",
    "postcss": "^8.4.31",
    "tailwindcss": "^3.3.5",
    "typescript": "^5.2.2",
    "vite": "^5.0.0"
  }
}


// File: components/ui_module/frontend/postcss.config.js
// Type: js

/** @type {import('postcss').Config} */
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

// File: components/ui_module/frontend/tailwind.config.js
// Type: js

/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {
      colors: {
        primary: {
          50: '#f0f9ff',
          100: '#e0f2fe',
          200: '#bae6fd',
          300: '#7dd3fc',
          400: '#38bdf8',
          500: '#0ea5e9',
          600: '#0284c7',
          700: '#0369a1',
          800: '#075985',
          900: '#0c4a6e',
        },
      },
      spacing: {
        '72': '18rem',
        '84': '21rem',
        '96': '24rem',
      },
    },
    extend: {},
  },
  plugins: [
    require('@tailwindcss/forms'),
  ],
}

// File: components/ui_module/frontend/tsconfig.json
// Type: json

{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"],
      "@components/*": ["src/components/*"],
      "@pages/*": ["src/pages/*"]
    },
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "strict": true,
    "noUnusedLocals": false,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}

// File: components/ui_module/frontend/tsconfig.node.json
// Type: json

{
    "compilerOptions": {
      "composite": true,
      "skipLibCheck": true,
      "module": "ESNext",
      "moduleResolution": "bundler",
      "allowSyntheticDefaultImports": true
    },
    "include": ["vite.config.ts"]
  }

// File: components/ui_module/frontend/vite.config.ts
// Type: ts

import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import path from 'path';

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: [
      { find: '@', replacement: path.resolve(__dirname, 'src') },
      { find: '@components', replacement: path.resolve(__dirname, 'src/components') },
      { find: '@pages', replacement: path.resolve(__dirname, 'src/pages') }
    ]
  },
  optimizeDeps: {
    include: [
      'recharts',
      'recharts-scale',
      'd3-scale',
      'd3-shape',
      'd3-path',
      'd3-format',
      'd3-time-format',
      'd3-array',
      'classnames',
      'react-smooth',
      'lodash',
    ],
  },
  build: {
    commonjsOptions: {
      include: [/node_modules/],
    },
  },
  server: {
    proxy: {
      '/api': {
        target: 'http://localhost:5000',
        changeOrigin: true
      },
      '/socket.io': {
        target: 'http://localhost:5000',
        ws: true
      }
    }
  }
});


// File: components/ui_module/frontend/src/App.tsx
// Type: tsx

import { Routes, Route } from 'react-router-dom';
import Layout from './components/Layout';
import { Dashboard, Strategy, Backtest, Portfolio, DataManagement, Settings } from './pages';

function App() {
  return (
    <Routes>
      <Route path="/" element={<Layout />}>
        <Route index element={<Dashboard />} />
        <Route path="strategy" element={<Strategy />} />
        <Route path="backtest" element={<Backtest />} />
        <Route path="portfolio" element={<Portfolio />} />
        <Route path="data" element={<DataManagement />} />
        <Route path="settings" element={<Settings />} />
      </Route>
    </Routes>
  );
}

export default App;

/* File: components/ui_module/frontend/src/index.css */
/* Type: css */

@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  body {
    @apply bg-gray-100;
  }
}

@layer components {
  .card {
    @apply bg-white rounded-lg shadow-sm p-6;
  }
  
  .btn-primary {
    @apply bg-indigo-600 text-white px-4 py-2 rounded-md hover:bg-indigo-700 transition-colors;
  }
  
  .btn-danger {
    @apply bg-red-600 text-white px-4 py-2 rounded-md hover:bg-red-700 transition-colors;
  }
}

// File: components/ui_module/frontend/src/main.tsx
// Type: tsx

import React from 'react';
import ReactDOM from 'react-dom/client';
import { BrowserRouter } from 'react-router-dom';
import App from './App';
import './index.css';

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <BrowserRouter>
      <App />
    </BrowserRouter>
  </React.StrictMode>
);

// File: components/ui_module/frontend/src/hooks/usePortfolioData.ts
// Type: ts

import { useState, useEffect } from 'react';

interface PortfolioData {
  history: Array<{
    date: string;
    value: number;
  }>;
  currentBalance: number;
  percentageChange: number;
}

export const usePortfolioData = (timeFilter: string) => {
  const [data, setData] = useState<PortfolioData | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        const response = await fetch(`/api/portfolio/history?period=${timeFilter}`);
        const result = await response.json();
        
        if (result.success && result.data) {
          const validData = {
            ...result.data,
            history: result.data.history
              .filter((point: any) => 
                typeof point.value === 'number' && 
                !isNaN(point.value) && 
                point.value > 0
              )
              .map((point: any) => ({
                date: point.date,
                value: Number(point.value)
              }))
          };
          setData(validData);
          setError(null);
        } else {
          setError(result.message || 'Failed to fetch portfolio data');
        }
      } catch (error) {
        setError('Error fetching portfolio data');
        console.error('Error fetching data:', error);
      } finally {
        setLoading(false);
      }
    };

    fetchData();
    const interval = setInterval(fetchData, 60000);
    return () => clearInterval(interval);
  }, [timeFilter]);

  return { data, loading, error };
};

// File: components/ui_module/frontend/src/components/BacktestConfigModal.tsx
// Type: tsx

import React, { useState, useEffect } from 'react';
import { XMarkIcon } from '@heroicons/react/24/outline';

interface BacktestConfigModalProps {
  isOpen: boolean;
  onClose: () => void;
  onBacktestComplete?: (plotUrl?: string, metrics?: any) => void;
}

const BacktestConfigModal: React.FC<BacktestConfigModalProps> = ({ isOpen, onClose, onBacktestComplete }) => {
  const [strategies, setStrategies] = useState<string[]>([]);
  const [formData, setFormData] = useState({
    strategy: '',
    symbol: '',
    dateRange: {
      start: '',
      end: ''
    },
    tradingHours: {
      start: '09:30',
      end: '16:00'
    },
    stopLoss: '',
    takeProfit: ''
  });

  const [isRunning, setIsRunning] = useState(false);

  useEffect(() => {
    if (isOpen) {
      fetch('/api/backtest/strategies')
        .then(response => response.json())
        .then(data => {
          if (data.success) {
            setStrategies(data.strategies);
          } else {
            console.error('Error fetching strategies:', data.message);
          }
        })
        .catch(error => {
          console.error('Error fetching strategies:', error);
        });
    }
  }, [isOpen]);

  const handleRunBacktest = () => {
    setIsRunning(true);
    const payload = {
      strategy: formData.strategy,
      symbol: formData.symbol,
      start_date: formData.dateRange.start,
      end_date: formData.dateRange.end,
      stop_loss: formData.stopLoss ? parseFloat(formData.stopLoss) : null,
      take_profit: formData.takeProfit ? parseFloat(formData.takeProfit) : null
    };

    fetch('/api/backtest/run', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload),
    })
    .then(res => res.json())
    .then(data => {
      setIsRunning(false);
      if (data.success) {
        // If backtest completed successfully, call onBacktestComplete if provided
        if (onBacktestComplete) {
          onBacktestComplete(data.plot_url, data.metrics);
        }
        // Close the modal automatically after success
        onClose();
      } else {
        console.error('Error running backtest:', data.message);
      }
    })
    .catch(err => {
      setIsRunning(false);
      console.error('Network error running backtest:', err);
    });
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-gray-500 bg-opacity-75 flex items-center justify-center z-50">
      <div className="bg-white rounded-lg shadow-xl w-full max-w-2xl">
        <div className="flex justify-between items-center p-6 border-b">
          <h2 className="text-xl font-semibold text-gray-900">Configure Backtest</h2>
          <button onClick={onClose} className="text-gray-400 hover:text-gray-500">
            <XMarkIcon className="h-6 w-6" />
          </button>
        </div>

        <div className="p-6 space-y-6">
          {isRunning && (
            <div className="text-center text-gray-700 mb-4">
              <span className="inline-block mr-2">Running backtest...</span>
              <div className="inline-block w-4 h-4 border-2 border-gray-300 border-t-transparent border-solid rounded-full animate-spin"></div>
            </div>
          )}

          {/* Form Fields */}
          <div className="grid grid-cols-2 gap-6">
            <div>
              <label className="block text-sm font-medium text-gray-700">Strategy</label>
              <select
                value={formData.strategy}
                onChange={e => setFormData({ ...formData, strategy: e.target.value })}
                className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
              >
                <option value="">Select a strategy</option>
                {strategies.map((strat, i) => (
                  <option key={i} value={strat}>{strat}</option>
                ))}
              </select>
            </div>
            <div>
              <label className="block text-sm font-medium text-gray-700">Symbol</label>
              <input
                type="text"
                value={formData.symbol}
                onChange={e => setFormData({ ...formData, symbol: e.target.value })}
                className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
                placeholder="AAPL"
              />
            </div>
          </div>

          <div className="grid grid-cols-2 gap-6">
            <div>
              <label className="block text-sm font-medium text-gray-700">Start Date</label>
              <input
                type="date"
                value={formData.dateRange.start}
                onChange={e => setFormData({ ...formData, dateRange: { ...formData.dateRange, start: e.target.value } })}
                className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
              />
            </div>
            <div>
              <label className="block text-sm font-medium text-gray-700">End Date</label>
              <input
                type="date"
                value={formData.dateRange.end}
                onChange={e => setFormData({ ...formData, dateRange: { ...formData.dateRange, end: e.target.value } })}
                className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
              />
            </div>
          </div>

          <div className="grid grid-cols-2 gap-6">
            <div>
              <label className="block text-sm font-medium text-gray-700">Stop Loss (%)</label>
              <input
                type="number"
                step="0.1"
                value={formData.stopLoss}
                onChange={e => setFormData({ ...formData, stopLoss: e.target.value })}
                className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
              />
            </div>
            <div>
              <label className="block text-sm font-medium text-gray-700">Take Profit (%)</label>
              <input
                type="number"
                step="0.1"
                value={formData.takeProfit}
                onChange={e => setFormData({ ...formData, takeProfit: e.target.value })}
                className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
              />
            </div>
          </div>

          <div className="flex justify-end space-x-4 pt-4">
            <button
              type="button"
              onClick={onClose}
              className="px-4 py-2 border border-gray-300 rounded-md text-sm font-medium text-gray-700 hover:bg-gray-50"
              disabled={isRunning}
            >
              Cancel
            </button>
            <button
              type="button"
              onClick={handleRunBacktest}
              className={`px-4 py-2 border border-transparent rounded-md shadow-sm text-sm font-medium text-white ${isRunning ? 'bg-gray-400 cursor-not-allowed' : 'bg-indigo-600 hover:bg-indigo-700'}`}
              disabled={isRunning}
            >
              {isRunning ? 'Running...' : 'Run Backtest'}
            </button>
          </div>
        </div>
      </div>
    </div>
  );
};

export default BacktestConfigModal;


// File: components/ui_module/frontend/src/components/Header.tsx
// Type: tsx

import React from 'react';
import { BellIcon } from '@heroicons/react/24/outline';

const Header: React.FC = () => {
  return (
    <header className="bg-white border-b border-gray-200">
      <div className="px-4 sm:px-6 lg:px-8">
        <div className="flex justify-between items-center h-16">
          <h1 className="text-2xl font-semibold text-gray-900">AI SMIF V2</h1>
          <div className="flex items-center space-x-4">
            <button 
              type="button"
              className="p-2 rounded-full text-gray-500 hover:text-gray-700 hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
            >
              <span className="sr-only">View notifications</span>
              <BellIcon className="h-5 w-5" />
            </button>
            <div className="h-8 w-8 rounded-full bg-indigo-600 flex items-center justify-center">
              <span className="text-sm font-medium text-white">U</span>
            </div>
          </div>
        </div>
      </div>
    </header>
  );
};

export default Header;

// File: components/ui_module/frontend/src/components/Layout.tsx
// Type: tsx

import React from 'react';
import { Outlet } from 'react-router-dom';
import Sidebar from './Sidebar';
import Header from './Header';

const Layout: React.FC = () => {
  return (
    <div className="min-h-screen bg-gray-100">
      <div className="flex h-screen overflow-hidden">
        <Sidebar />
        <div className="flex-1 flex flex-col overflow-hidden">
          <Header />
          <main className="flex-1 overflow-y-auto bg-gray-100">
            <div className="container mx-auto px-4 sm:px-6 lg:px-8 py-8">
              <Outlet />
            </div>
          </main>
        </div>
      </div>
    </div>
  );
};

export default Layout;

// File: components/ui_module/frontend/src/components/NewStrategyModal.tsx
// Type: tsx

import React, { useState } from 'react';
import { XMarkIcon, PlusIcon, TrashIcon } from '@heroicons/react/24/outline';

interface TradingRule {
  indicator: string;
  operator: string;
  value: string;
  logicalOperator: string;
  action: string;
}

interface StrategyFormData {
  name: string;
  description: string;
  rules: TradingRule[];
  stopLoss: number;
  takeProfit: number;
}

interface NewStrategyModalProps {
  isOpen: boolean;
  onClose: () => void;
}

export const NewStrategyModal: React.FC<NewStrategyModalProps> = ({ isOpen, onClose }) => {
  const [formData, setFormData] = useState<StrategyFormData>({
    name: '',
    description: '',
    rules: [{
      indicator: 'Price',
      operator: 'Greater Than',
      value: '0',
      logicalOperator: 'AND',
      action: 'Buy'
    }],
    stopLoss: 2,
    takeProfit: 5
  });

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      const response = await fetch('/api/strategies', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(formData),
      });
      if (response.ok) {
        onClose();
      }
    } catch (error) {
      console.error('Error creating strategy:', error);
    }
  };

  const addRule = () => {
    setFormData(prev => ({
      ...prev,
      rules: [...prev.rules, {
        indicator: 'Price',
        operator: 'Greater Than',
        value: '0',
        logicalOperator: 'AND',
        action: 'Buy'
      }]
    }));
  };

  const removeRule = (index: number) => {
    setFormData(prev => ({
      ...prev,
      rules: prev.rules.filter((_, i) => i !== index)
    }));
  };

  const updateRule = (index: number, field: keyof TradingRule, value: string) => {
    setFormData(prev => ({
      ...prev,
      rules: prev.rules.map((rule, i) => 
        i === index ? { ...rule, [field]: value } : rule
      )
    }));
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-gray-500 bg-opacity-75 flex items-center justify-center">
      <div className="bg-white rounded-lg shadow-xl w-full max-w-3xl max-h-[90vh] overflow-y-auto">
        <div className="flex justify-between items-center p-6 border-b">
          <h2 className="text-xl font-semibold text-gray-900">New Strategy</h2>
          <button onClick={onClose} className="text-gray-400 hover:text-gray-500">
            <XMarkIcon className="h-6 w-6" />
          </button>
        </div>

        <form onSubmit={handleSubmit} className="p-6 space-y-6">
          {/* Strategy Name */}
          <div>
            <label htmlFor="name" className="block text-sm font-medium text-gray-700">
              Strategy Name
            </label>
            <input
              type="text"
              id="name"
              value={formData.name}
              onChange={e => setFormData(prev => ({ ...prev, name: e.target.value }))}
              className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
            />
          </div>

          {/* Description */}
          <div>
            <label htmlFor="description" className="block text-sm font-medium text-gray-700">
              Description
            </label>
            <textarea
              id="description"
              rows={3}
              value={formData.description}
              onChange={e => setFormData(prev => ({ ...prev, description: e.target.value }))}
              className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
            />
          </div>

          {/* Trading Rules */}
          <div>
            <div className="flex justify-between items-center mb-4">
              <h3 className="text-lg font-medium text-gray-900">Trading Rules</h3>
              <button
                type="button"
                onClick={addRule}
                className="inline-flex items-center px-3 py-1 border border-transparent text-sm font-medium rounded-md text-indigo-600 hover:text-indigo-500"
              >
                <PlusIcon className="h-5 w-5 mr-1" />
                Add Rule
              </button>
            </div>

            <div className="space-y-4">
              {formData.rules.map((rule, index) => (
                <div key={index} className="flex items-start space-x-4 bg-gray-50 p-4 rounded-md">
                  <div className="flex-grow grid grid-cols-5 gap-4">
                    <select
                      value={rule.indicator}
                      onChange={e => updateRule(index, 'indicator', e.target.value)}
                      className="rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
                    >
                      <option>Price</option>
                      <option>Volume</option>
                      <option>RSI</option>
                      <option>MACD</option>
                    </select>
                    <select
                      value={rule.operator}
                      onChange={e => updateRule(index, 'operator', e.target.value)}
                      className="rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
                    >
                      <option>Greater Than</option>
                      <option>Less Than</option>
                      <option>Equals</option>
                    </select>
                    <input
                      type="text"
                      value={rule.value}
                      onChange={e => updateRule(index, 'value', e.target.value)}
                      className="rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
                    />
                    <select
                      value={rule.logicalOperator}
                      onChange={e => updateRule(index, 'logicalOperator', e.target.value)}
                      className="rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
                    >
                      <option>AND</option>
                      <option>OR</option>
                    </select>
                    <select
                      value={rule.action}
                      onChange={e => updateRule(index, 'action', e.target.value)}
                      className="rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
                    >
                      <option>Buy</option>
                      <option>Sell</option>
                    </select>
                  </div>
                  <button
                    type="button"
                    onClick={() => removeRule(index)}
                    className="text-red-500 hover:text-red-600"
                  >
                    <TrashIcon className="h-5 w-5" />
                  </button>
                </div>
              ))}
            </div>
          </div>

          {/* Risk Management */}
          <div>
            <h3 className="text-lg font-medium text-gray-900 mb-4">Risk Management</h3>
            <div className="grid grid-cols-2 gap-4">
              <div>
                <label htmlFor="stopLoss" className="block text-sm font-medium text-gray-700">
                  Stop Loss (%)
                </label>
                <input
                  type="number"
                  id="stopLoss"
                  value={formData.stopLoss}
                  onChange={e => setFormData(prev => ({ ...prev, stopLoss: Number(e.target.value) }))}
                  className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
                />
              </div>
              <div>
                <label htmlFor="takeProfit" className="block text-sm font-medium text-gray-700">
                  Take Profit (%)
                </label>
                <input
                  type="number"
                  id="takeProfit"
                  value={formData.takeProfit}
                  onChange={e => setFormData(prev => ({ ...prev, takeProfit: Number(e.target.value) }))}
                  className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
                />
              </div>
            </div>
          </div>

          {/* Form Actions */}
          <div className="flex justify-end space-x-4">
            <button
              type="button"
              onClick={onClose}
              className="px-4 py-2 border border-gray-300 rounded-md text-sm font-medium text-gray-700 hover:bg-gray-50"
            >
              Cancel
            </button>
            <button
              type="submit"
              className="px-4 py-2 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
            >
              Save Strategy
            </button>
          </div>
        </form>
      </div>
    </div>
  );
};

export default NewStrategyModal;

// File: components/ui_module/frontend/src/components/Sidebar.tsx
// Type: tsx

import React from 'react';
import { Link, useLocation } from 'react-router-dom';
import {
  HomeIcon,
  ChartBarIcon,
  ArrowTrendingUpIcon,
  FolderIcon,
  DocumentChartBarIcon,
  Cog6ToothIcon,
} from '@heroicons/react/24/outline';

const navigation = [
  { name: 'Dashboard', href: '/', icon: HomeIcon },
  { name: 'Strategy', href: '/strategy', icon: ChartBarIcon },
  { name: 'Backtest', href: '/backtest', icon: ArrowTrendingUpIcon },
  { name: 'Portfolio', href: '/portfolio', icon: FolderIcon },
  { name: 'Data Management', href: '/data', icon: DocumentChartBarIcon },
  { name: 'Settings', href: '/settings', icon: Cog6ToothIcon },
];

const Sidebar: React.FC = () => {
  const location = useLocation();

  return (
    <div className="hidden lg:flex lg:flex-shrink-0">
      <div className="flex flex-col w-64">
        <div className="flex flex-col flex-grow bg-gray-800 pt-5 pb-4 overflow-y-auto">
          <div className="flex items-center flex-shrink-0 px-4">
            <span className="text-xl font-bold text-white">Trading System</span>
          </div>
          <nav className="mt-8 flex-1 px-2 space-y-1" aria-label="Sidebar">
            {navigation.map((item) => {
              const isActive = location.pathname === item.href;
              const Icon = item.icon;
              return (
                <Link
                  key={item.name}
                  to={item.href}
                  className={`
                    group flex items-center px-2 py-2 text-sm font-medium rounded-md
                    ${isActive 
                      ? 'bg-gray-900 text-white' 
                      : 'text-gray-300 hover:bg-gray-700 hover:text-white'
                    }
                  `}
                >
                  <Icon
                    className={`
                      mr-3 flex-shrink-0 w-5 h-5
                      ${isActive 
                        ? 'text-gray-300' 
                        : 'text-gray-400 group-hover:text-gray-300'
                      }
                    `}
                    aria-hidden="true"
                  />
                  {item.name}
                </Link>
              );
            })}
          </nav>
        </div>
      </div>
    </div>
  );
};

export default Sidebar;

// File: components/ui_module/frontend/src/components/index.ts
// Type: ts

export { default as Layout } from './Layout';
export { default as Sidebar } from './Sidebar';
export { default as Header } from './Header';

// File: components/ui_module/frontend/src/components/portfolio/CurrentPositions.tsx
// Type: tsx

import React, { useState, useEffect } from 'react';

interface Position {
  symbol: string;
  qty: number;
  avgEntryPrice: number;
  marketValue: number;
  currentPrice: number;
  unrealizedPL: number;
  unrealizedPLPercent: number;
  change: number;
}

const CurrentPositions: React.FC = () => {
  const [positions, setPositions] = useState<Position[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchPositions = async () => {
      try {
        const response = await fetch('/api/positions');
        const data = await response.json();
        
        if (data.success) {
          setPositions(data.positions);
        } else {
          setError(data.message);
        }
      } catch (err) {
        setError('Failed to fetch positions');
      } finally {
        setLoading(false);
      }
    };

    fetchPositions();
    const interval = setInterval(fetchPositions, 60000); // Refresh every minute
    return () => clearInterval(interval);
  }, []);

  if (loading) {
    return (
      <div className="flex justify-center items-center h-32">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary-600"></div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="bg-red-50 text-red-800 p-4 rounded-lg">
        <p>Error: {error}</p>
      </div>
    );
  }

  if (positions.length === 0) {
    return <div className="text-gray-500">No open positions</div>;
  }

  return (
    <div className="overflow-x-auto">
      <table className="min-w-full divide-y divide-gray-200">
        <thead className="bg-gray-50">
          <tr>
            <th scope="col" className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Symbol</th>
            <th scope="col" className="px-3 py-2 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">Qty</th>
            <th scope="col" className="px-3 py-2 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">Entry</th>
            <th scope="col" className="px-3 py-2 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">Current</th>
            <th scope="col" className="px-3 py-2 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">Value</th>
            <th scope="col" className="px-3 py-2 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">P/L</th>
            <th scope="col" className="px-3 py-2 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">%</th>
          </tr>
        </thead>
        <tbody className="bg-white divide-y divide-gray-200">
          {positions.map((position) => (
            <tr key={position.symbol} className="hover:bg-gray-50">
              <td className="px-3 py-2 whitespace-nowrap text-sm font-medium text-gray-900">
                {position.symbol}
              </td>
              <td className="px-3 py-2 whitespace-nowrap text-sm text-right text-gray-900">
                {position.qty.toLocaleString()}
              </td>
              <td className="px-3 py-2 whitespace-nowrap text-sm text-right text-gray-900">
                ${position.avgEntryPrice.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}
              </td>
              <td className="px-3 py-2 whitespace-nowrap text-sm text-right text-gray-900">
                ${position.currentPrice.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}
              </td>
              <td className="px-3 py-2 whitespace-nowrap text-sm text-right text-gray-900">
                ${position.marketValue.toLocaleString(undefined, { minimumFractionDigits: 2 })}
              </td>
              <td className={`px-3 py-2 whitespace-nowrap text-sm text-right ${position.unrealizedPL >= 0 ? 'text-green-600' : 'text-red-600'}`}>
                ${position.unrealizedPL.toLocaleString(undefined, { minimumFractionDigits: 2 })}
              </td>
              <td className={`px-3 py-2 whitespace-nowrap text-sm text-right ${position.unrealizedPLPercent >= 0 ? 'text-green-600' : 'text-red-600'}`}>
                {position.unrealizedPLPercent >= 0 ? '+' : ''}
                {position.unrealizedPLPercent.toFixed(2)}%
              </td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
};

export default CurrentPositions;

// File: components/ui_module/frontend/src/components/portfolio/RecentTrades.tsx
// Type: tsx

import React, { useState, useEffect } from 'react';

interface Trade {
  symbol: string;
  side: string;
  qty: number;
  price: number;
  time: string;
  order_id: string;
  total_value: number;
}

const RecentTrades: React.FC = () => {
  const [trades, setTrades] = useState<Trade[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchTrades = async () => {
      try {
        const response = await fetch('/api/recent-trades');
        const data = await response.json();
        
        if (data.success) {
          setTrades(data.trades);
        } else {
          setError(data.message);
        }
      } catch (err) {
        setError('Failed to fetch recent trades');
      } finally {
        setLoading(false);
      }
    };

    fetchTrades();
    const interval = setInterval(fetchTrades, 60000); // Refresh every minute
    return () => clearInterval(interval);
  }, []);

  if (loading) {
    return (
      <div className="flex justify-center items-center h-32">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary-600"></div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="bg-red-50 text-red-800 p-4 rounded-lg">
        <p>Error: {error}</p>
      </div>
    );
  }

  if (trades.length === 0) {
    return <div className="text-gray-500">No recent trades</div>;
  }

  return (
    <div className="overflow-x-auto">
      <table className="min-w-full divide-y divide-gray-200">
        <thead className="bg-gray-50">
          <tr>
            <th scope="col" className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Time</th>
            <th scope="col" className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Symbol</th>
            <th scope="col" className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Side</th>
            <th scope="col" className="px-3 py-2 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">Quantity</th>
            <th scope="col" className="px-3 py-2 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">Price</th>
            <th scope="col" className="px-3 py-2 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">Total Value</th>
          </tr>
        </thead>
        <tbody className="bg-white divide-y divide-gray-200">
          {trades.map((trade) => (
            <tr key={trade.order_id} className="hover:bg-gray-50">
              <td className="px-3 py-2 whitespace-nowrap text-sm text-gray-900">
                {new Date(trade.time).toLocaleString()}
              </td>
              <td className="px-3 py-2 whitespace-nowrap text-sm font-medium text-gray-900">
                {trade.symbol}
              </td>
              <td className={`px-3 py-2 whitespace-nowrap text-sm ${trade.side.toLowerCase() === 'buy' ? 'text-green-600' : 'text-red-600'}`}>
                {trade.side}
              </td>
              <td className="px-3 py-2 whitespace-nowrap text-sm text-right text-gray-900">
                {trade.qty.toLocaleString()}
              </td>
              <td className="px-3 py-2 whitespace-nowrap text-sm text-right text-gray-900">
                ${trade.price.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}
              </td>
              <td className="px-3 py-2 whitespace-nowrap text-sm text-right text-gray-900">
                ${trade.total_value.toLocaleString(undefined, { minimumFractionDigits: 2 })}
              </td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
};

export default RecentTrades;

// File: components/ui_module/frontend/src/components/dashboard/ChartToolTip.tsx
// Type: tsx

import React from 'react';
import { formatCurrency, formatDate } from '../../utils/formatters';

interface ChartTooltipProps {
  active?: boolean;
  payload?: Array<any>;
  label?: string;
  timeFilter: string;
}

const ChartTooltip: React.FC<ChartTooltipProps> = ({ active, payload, label, timeFilter }) => {
  if (!active || !payload || !payload.length) {
    return null;
  }

  return (
    <div className="bg-white p-3 border rounded shadow-lg">
      <p className="font-semibold text-gray-900">
        {formatCurrency(payload[0].value)}
      </p>
      <p className="text-sm text-gray-500">
        {formatDate(label, timeFilter === '1D')}
      </p>
    </div>
  );
};

export default ChartTooltip;

// File: components/ui_module/frontend/src/components/dashboard/DashboardChart copy.tsx
// Type: tsx

// src/components/dashboard/DashboardChart.tsx

import React, { useState, useEffect } from 'react';
import {
  Chart as ChartJS,
  LineElement,
  PointElement,
  CategoryScale,
  LinearScale,
  Tooltip as ChartTooltip,
  TimeScale,
  Legend
} from 'chart.js';
import 'chartjs-adapter-date-fns';
import { Line } from 'react-chartjs-2';

// Register Chart.js components
ChartJS.register(
  LineElement,
  PointElement,
  CategoryScale,
  LinearScale,
  ChartTooltip,
  TimeScale,
  Legend
);

// Define the structure of each data point
interface PortfolioData {
  date: string;
  value: number;
}

// Define the structure of the fetched data
interface ChartData {
  history: PortfolioData[];
  currentBalance: number;
  percentageChange: number;
}

const DashboardChart: React.FC = () => {
  const timeFilters: Array<'1D' | '1W' | '1M' | '3M' | '1Y' | 'ALL'> = ['1D', '1W', '1M', '3M', '1Y', 'ALL'];
  const [timeFilter, setTimeFilter] = useState<'1D' | '1W' | '1M' | '3M' | '1Y' | 'ALL'>('1M');
  const [data, setData] = useState<ChartData | null>(null);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchData = async () => {
      setLoading(true);
      setError(null);
      try {
        const response = await fetch(`/api/portfolio/history?period=${timeFilter}`);
        const result = await response.json();
        if (result.success) {
          const processedData: ChartData = {
            history: result.data.history.map((item: any) => ({
              date: item.date,
              value: Number(item.value)
            })),
            currentBalance: Number(result.data.currentBalance),
            percentageChange: Number(result.data.percentageChange)
          };
          setData(processedData);
        } else {
          setError('Failed to fetch data.');
        }
      } catch (err) {
        console.error('Error fetching data:', err);
        setError('An error occurred while fetching data.');
      } finally {
        setLoading(false);
      }
    };

    fetchData();
    const interval = setInterval(fetchData, 60000);
    return () => clearInterval(interval);
  }, [timeFilter]);

  const formatCurrency = (value: number): string => {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD',
      minimumFractionDigits: 2,
      maximumFractionDigits: 2
    }).format(value);
  };

  if (loading) {
    return <div className="text-center">Loading...</div>;
  }

  if (error) {
    return <div className="text-center text-red-500">{error}</div>;
  }

  if (!data || !data.history.length) {
    return <div className="text-center">No data available.</div>;
  }

  // Prepare Chart.js data
  const chartData = {
    labels: data.history.map(d => d.date),
    datasets: [
      {
        label: 'Portfolio Value',
        data: data.history.map(d => d.value),
        borderColor: data.percentageChange >= 0 ? '#16a34a' : '#dc2626',
        borderWidth: 2,
        pointRadius: 0,
        lineTension: 0.1
      }
    ]
  };

  // Determine min and max from data
  const values = data.history.map(d => d.value);
  const minVal = Math.min(...values);
  const maxVal = Math.max(...values);

  // Chart.js configuration
  const options = {
    responsive: true,
    maintainAspectRatio: false as const,
    scales: {
      x: {
        type: 'time' as const,
        time: {
          unit: 'day'
        },
        ticks: {
          callback: function (value: any, index: number) {
            // The chart uses timestamps internally; format the label
            const labelDate = new Date((this.getLabelForValue(value) as string));
            return `${labelDate.getMonth() + 1}/${labelDate.getDate()}`;
          },
          color: '#4B5563',
        },
        grid: {
          color: 'rgba(0,0,0,0.05)'
        }
      },
      y: {
        suggestedMin: minVal,
        suggestedMax: maxVal,
        ticks: {
          callback: function(value: number) {
            return formatCurrency(value);
          },
          color: '#4B5563'
        },
        grid: {
          color: 'rgba(0,0,0,0.05)'
        }
      }
    },
    plugins: {
      tooltip: {
        callbacks: {
          label: function(context: any) {
            const val = context.parsed.y;
            return `${formatCurrency(val)}`;
          },
          title: function(context: any) {
            if (context.length) {
              const dateStr = context[0].label;
              const date = new Date(dateStr);
              return `${date.getMonth() + 1}/${date.getDate()}/${date.getFullYear()}`;
            }
            return '';
          }
        }
      },
      legend: {
        display: false
      }
    }
  };

  return (
    <div>
      <div className="mt-2">
        <p className="text-2xl font-semibold">{formatCurrency(data.currentBalance)}</p>
        <p className={`text-sm ${data.percentageChange >= 0 ? 'text-green-500' : 'text-red-500'}`}>
          {data.percentageChange >= 0 ? '+' : ''}
          {data.percentageChange.toFixed(2)}%
        </p>
      </div>

      <div className="flex space-x-2 mt-4">
        {timeFilters.map((period) => (
          <button
            key={period}
            onClick={() => setTimeFilter(period)}
            className={`px-3 py-1 text-sm rounded-full transition-colors ${
              timeFilter === period
                ? 'bg-green-600 text-white'
                : 'text-gray-600 hover:bg-gray-100'
            }`}
          >
            {period}
          </button>
        ))}
      </div>

      <div className="h-64 mt-4 flex justify-center items-center">
        <div className="w-full h-full">
          <Line data={chartData} options={options} />
        </div>
      </div>
    </div>
  );
};

export default DashboardChart;


// File: components/ui_module/frontend/src/components/dashboard/DashboardChart.tsx
// Type: tsx

import React, { useState } from 'react';
import {
  ResponsiveContainer,
  AreaChart,
  Area,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
} from 'recharts';
import { formatCurrency, formatDate } from '../../utils/formatters';

interface ChartData {
  history: Array<{
    date: string;
    value: number;
  }>;
  currentBalance: number;
  percentageChange: number;
}

// Time filter type
type TimeFilterOption = '1D' | '1W' | '1M' | '3M' | '1Y' | 'ALL';

// Custom tooltip component
const CustomTooltip = ({ active, payload, label, timeFilter }: any) => {
  if (!active || !payload || !payload.length) return null;

  return (
    <div className="bg-white p-3 border rounded shadow-lg">
      <p className="font-semibold text-gray-900">
        {formatCurrency(payload[0].value)}
      </p>
      <p className="text-sm text-gray-500">
        {formatDate(label, timeFilter === '1D')}
      </p>
    </div>
  );
};

// Time filter component
const TimeFilter = ({ selected, onChange }: { selected: TimeFilterOption; onChange: (filter: TimeFilterOption) => void }) => {
  const options: TimeFilterOption[] = ['1D', '1W', '1M', '3M', '1Y', 'ALL'];

  return (
    <div className="flex space-x-2">
      {options.map((period) => (
        <button
          key={period}
          onClick={() => onChange(period)}
          className={`px-3 py-1 text-sm rounded-full transition-colors ${
            selected === period 
              ? 'bg-green-600 text-white' 
              : 'text-gray-600 hover:bg-gray-100'
          }`}
        >
          {period}
        </button>
      ))}
    </div>
  );
};

// Portfolio summary component
const PortfolioSummary = ({ balance, percentageChange }: { balance: number; percentageChange: number }) => {
  return (
    <div>
      <p className="text-2xl font-semibold">{formatCurrency(balance)}</p>
      <p className={`text-sm ${percentageChange >= 0 ? 'text-green-500' : 'text-red-500'}`}>
        {percentageChange >= 0 ? '+' : ''}{percentageChange.toFixed(2)}%
      </p>
    </div>
  );
};

const DashboardChart: React.FC = () => {
  const [timeFilter, setTimeFilter] = useState<TimeFilterOption>('1M');
  const [data, setData] = useState<ChartData | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  React.useEffect(() => {
    const fetchData = async () => {
      try {
        const response = await fetch(`/api/portfolio/history?period=${timeFilter}`);
        const result = await response.json();
        
        if (result.success && result.data) {
          const validData = {
            ...result.data,
            history: result.data.history
              .filter((point: any) => 
                typeof point.value === 'number' && 
                !isNaN(point.value) && 
                point.value > 0
              )
              .map((point: any) => ({
                date: point.date,
                value: Number(point.value)
              }))
          };
          setData(validData);
          setError(null);
        } else {
          setError(result.message || 'Failed to fetch portfolio data');
        }
      } catch (error) {
        setError('Error fetching portfolio data');
        console.error('Error fetching data:', error);
      } finally {
        setLoading(false);
      }
    };

    fetchData();
    const interval = setInterval(fetchData, 60000);
    return () => clearInterval(interval);
  }, [timeFilter]);

  if (loading) {
    return <div className="h-64 flex items-center justify-center">Loading...</div>;
  }

  if (error) {
    return <div className="h-64 flex items-center justify-center text-red-500">{error}</div>;
  }

  if (!data || !data.history.length) {
    return <div className="h-64 flex items-center justify-center">No data available</div>;
  }

  return (
    <div className="p-6">
      <h3 className="text-lg font-medium leading-6 text-gray-900">Portfolio Performance</h3>
      
      <div className="mt-2">
        <PortfolioSummary 
          balance={data.currentBalance}
          percentageChange={data.percentageChange}
        />
      </div>

      <div className="mt-4">
        <TimeFilter 
          selected={timeFilter}
          onChange={setTimeFilter}
        />
      </div>

      <div className="mt-4" style={{ height: '400px' }}>
        <ResponsiveContainer width="100%" height="100%">
          <AreaChart
            data={data.history}
            margin={{ top: 10, right: 30, left: 10, bottom: 0 }}
          >
            <defs>
              <linearGradient id="colorValue" x1="0" y1="0" x2="0" y2="1">
                <stop offset="5%" stopColor="#22c55e" stopOpacity={0.2}/>
                <stop offset="95%" stopColor="#22c55e" stopOpacity={0}/>
              </linearGradient>
            </defs>
            <CartesianGrid 
              strokeDasharray="3 3" 
              vertical={false}
              stroke="#E5E7EB"
            />
            <XAxis
              dataKey="date"
              tickFormatter={(date) => formatDate(date, timeFilter === '1D')}
              tick={{ fill: '#6B7280', fontSize: 12 }}
              axisLine={{ stroke: '#E5E7EB' }}
              tickLine={{ stroke: '#E5E7EB' }}
            />
            <YAxis
              tickFormatter={formatCurrency}
              tick={{ fill: '#6B7280', fontSize: 12 }}
              axisLine={{ stroke: '#E5E7EB' }}
              tickLine={{ stroke: '#E5E7EB' }}
              width={80}
              domain={['dataMin', 'dataMax']}
            />
            <Tooltip content={<CustomTooltip timeFilter={timeFilter} />} />
            <Area
              type="monotone"
              dataKey="value"
              stroke="#22c55e"
              fillOpacity={1}
              fill="url(#colorValue)"
              strokeWidth={2}
            />
          </AreaChart>
        </ResponsiveContainer>
      </div>
    </div>
  );
};

export default DashboardChart;

// File: components/ui_module/frontend/src/components/dashboard/DashboardMetrics.tsx
// Type: tsx

// src/components/dashboard/DashboardMetrics.tsx

import React, { useState, useEffect } from 'react';

interface DashboardData {
  account_balance: number;
  cash_available: number;
  today_pl: number;
  today_return: number;
}

const DashboardMetrics: React.FC = () => {
  const [data, setData] = useState<DashboardData | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchData = async () => {
      console.log("Fetching dashboard data...");
      try {
        const response = await fetch('/api/dashboard-data');
        console.log("Received response:", response);
        
        if (!response.ok) {
          const errorText = await response.text();
          console.error("Non-OK response:", response.status, errorText);
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const result = await response.json();
        console.log("Parsed JSON result:", result);
        
        if (result.success) {
          console.log("Dashboard data fetched successfully:", result.data);
          setData(result.data);
        } else {
          console.error("API returned success=false with message:", result.message);
          setError(result.message || 'Failed to fetch data');
        }
      } catch (err) {
        console.error("Error fetching dashboard data:", err);
        setError('Failed to fetch dashboard data');
      } finally {
        setLoading(false);
        console.log("Loading state set to false");
      }
    };

    fetchData();
    const interval = setInterval(fetchData, 60000); // Refresh every minute
    return () => clearInterval(interval);
  }, []);

  if (loading) {
    return (
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
        {[...Array(4)].map((_, i) => (
          <div key={i} className="bg-white rounded-lg shadow p-4 animate-pulse">
            <div className="h-4 bg-gray-200 rounded w-1/2 mb-2"></div>
            <div className="h-6 bg-gray-200 rounded"></div>
          </div>
        ))}
      </div>
    );
  }

  if (error) {
    return (
      <div className="bg-red-50 text-red-800 p-4 rounded-lg">
        <p>Error: {error}</p>
      </div>
    );
  }

  if (!data) return null;

  const metrics = [
    {
      title: 'Account Balance',
      value: `$${data.account_balance.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`,
      className: 'text-gray-900'
    },
    {
      title: 'Cash Available',
      value: `$${data.cash_available.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`,
      className: 'text-gray-900'
    },
    {
      title: "Today's P/L",
      value: `$${data.today_pl.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`,
      className: data.today_pl >= 0 ? 'text-green-600' : 'text-red-600'
    },
    {
      title: "Today's Return",
      value: `${data.today_return >= 0 ? '+' : ''}${data.today_return.toFixed(2)}%`,
      className: data.today_return >= 0 ? 'text-green-600' : 'text-red-600'
    }
  ];

  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
      {metrics.map((metric, index) => (
        <div key={index} className="bg-white rounded-lg shadow p-4">
          <h3 className="text-sm font-medium text-gray-500">{metric.title}</h3>
          <p className={`mt-1 text-xl font-semibold ${metric.className}`}>
            {metric.value}
          </p>
        </div>
      ))}
    </div>
  );
};

export default DashboardMetrics;


// File: components/ui_module/frontend/src/components/dashboard/MarketOverview.tsx
// Type: tsx

import React, { useState, useEffect } from 'react';
import { LineChart, Line, XAxis, ResponsiveContainer } from 'recharts';

interface TrendPoint {
  time: string;
  price: number;
}

interface MarketItem {
  symbol: string;
  name: string;
  price: number | string; // Adjusted to allow string for BTC
  change: number;
  trend: TrendPoint[];
  exchange?: string; // If you added exchange info on the backend
}

const MarketOverview: React.FC = () => {
  const [marketData, setMarketData] = useState<MarketItem[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string|null>(null);

  useEffect(() => {
    const fetchMarketData = async () => {
      try {
        const response = await fetch('/api/market-overview');
        const result = await response.json();

        if (result.success) {
          // result.data should be an array of MarketItem
          setMarketData(result.data);
        } else {
          setError(result.message);
        }
      } catch (err) {
        console.error('Error fetching market data:', err);
        setError('Failed to fetch market data');
      } finally {
        setLoading(false);
      }
    };

    fetchMarketData();
    const interval = setInterval(fetchMarketData, 60000);
    return () => clearInterval(interval);
  }, []);

  if (loading) {
    return (
      <div className="bg-white p-6 rounded-lg shadow-lg">
        <h2 className="text-xl font-semibold mb-4">Market Overview</h2>
        <div className="flex items-center justify-center h-40">
          <p className="text-gray-500">Loading market data...</p>
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="bg-white p-6 rounded-lg shadow-lg">
        <h2 className="text-xl font-semibold mb-4">Market Overview</h2>
        <div className="text-red-500">
          {error}
        </div>
      </div>
    );
  }

  return (
    <div className="bg-white p-6 rounded-lg shadow-lg">
      <h2 className="text-xl font-semibold mb-4">Market Overview</h2>
      <div className="space-y-2">
        {marketData.map((item) => {
          // Handle formatting of the price
          let priceDisplay: string;
          if (typeof item.price === 'number') {
            priceDisplay = item.price.toFixed(2);
          } else {
            // If it's a string (like BTC), just use it as is
            // Assuming BTC is formatted from backend as a string with commas, etc.
            priceDisplay = item.price;
          }

          // Determine line color for trend
          // If trend is available and has more than one point, check first/last to determine up or down
          let lineColor = '#16a34a'; // green by default
          if (item.trend && item.trend.length > 1) {
            const firstPrice = item.trend[0].price;
            const lastPrice = item.trend[item.trend.length - 1].price;
            if (lastPrice < firstPrice) {
              lineColor = '#dc2626'; // red if price went down
            }
          }

          return (
            <div key={item.symbol} className="flex items-center space-x-4 p-2 rounded-lg">
              <div className="flex-1">
                <h3 className="text-md font-medium text-gray-900">{item.name}</h3>
                <p className="text-sm text-gray-500">{item.symbol}</p>
              </div>
              <div className="text-right">
                <p className="text-lg font-semibold text-gray-900">${priceDisplay}</p>
                <p className={`text-sm ${item.change >= 0 ? 'text-green-600' : 'text-red-600'}`}>
                  {(item.change >= 0 ? '+' : '')}{item.change.toFixed(2)}%
                </p>
              </div>
              <div style={{ width: 80, height: 40 }} className="flex justify-center items-center">
                {item.trend && item.trend.length > 0 && (
                  <ResponsiveContainer width="100%" height="100%">
                    <LineChart data={item.trend} margin={{ top: 5, right: 5, bottom: 5, left: 5 }}>
                      <XAxis dataKey="time" hide={true} padding={{ left: 10, right: 10 }} />
                      <Line type="monotone" dataKey="price" stroke={lineColor} strokeWidth={2} dot={false} />
                    </LineChart>
                  </ResponsiveContainer>
                )}
              </div>
            </div>
          );
        })}
      </div>
    </div>
  );
};

export default MarketOverview;


// File: components/ui_module/frontend/src/components/dashboard/PortfolioChart.tsx
// Type: tsx

import React from 'react';
import {
  ResponsiveContainer,
  AreaChart,
  Area,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
} from 'recharts';
import { formatCurrency, formatDate } from '../../utils/formatters';
import ChartTooltip from './ChartTooltip';

interface PortfolioChartProps {
  data: Array<{ date: string; value: number }>;
  timeFilter: string;
}

const PortfolioChart: React.FC<PortfolioChartProps> = ({ data, timeFilter }) => {
  return (
    <div style={{ height: '400px' }}>
      <ResponsiveContainer width="100%" height="100%">
        <AreaChart
          data={data}
          margin={{ top: 10, right: 30, left: 10, bottom: 0 }}
        >
          <defs>
            <linearGradient id="colorValue" x1="0" y1="0" x2="0" y2="1">
              <stop offset="5%" stopColor="#22c55e" stopOpacity={0.2}/>
              <stop offset="95%" stopColor="#22c55e" stopOpacity={0}/>
            </linearGradient>
          </defs>
          <CartesianGrid 
            strokeDasharray="3 3" 
            vertical={false}
            stroke="#E5E7EB"
          />
          <XAxis
            dataKey="date"
            tickFormatter={(date) => formatDate(date, timeFilter === '1D')}
            tick={{ fill: '#6B7280', fontSize: 12 }}
            axisLine={{ stroke: '#E5E7EB' }}
            tickLine={{ stroke: '#E5E7EB' }}
          />
          <YAxis
            tickFormatter={formatCurrency}
            tick={{ fill: '#6B7280', fontSize: 12 }}
            axisLine={{ stroke: '#E5E7EB' }}
            tickLine={{ stroke: '#E5E7EB' }}
            width={80}
          />
          <Tooltip content={<ChartTooltip timeFilter={timeFilter} />} />
          <Area
            type="monotone"
            dataKey="value"
            stroke="#22c55e"
            fillOpacity={1}
            fill="url(#colorValue)"
            strokeWidth={2}
          />
        </AreaChart>
      </ResponsiveContainer>
    </div>
  );
};

export default PortfolioChart;

// File: components/ui_module/frontend/src/components/dashboard/PortfolioSummary.tsx
// Type: tsx

import React from 'react';
import { formatCurrency } from '../../utils/formatters';

interface PortfolioSummaryProps {
  balance: number;
  percentageChange: number;
}

const PortfolioSummary: React.FC<PortfolioSummaryProps> = ({ balance, percentageChange }) => {
  return (
    <div>
      <p className="text-2xl font-semibold">{formatCurrency(balance)}</p>
      <p className={`text-sm ${percentageChange >= 0 ? 'text-green-500' : 'text-red-500'}`}>
        {percentageChange >= 0 ? '+' : ''}{percentageChange.toFixed(2)}%
      </p>
    </div>
  );
};

export default PortfolioSummary;

// File: components/ui_module/frontend/src/components/dashboard/TimeFilter.tsx
// Type: tsx

import React from 'react';

type TimeFilterOption = '1D' | '1W' | '1M' | '3M' | '1Y' | 'ALL';

interface TimeFilterProps {
  selected: TimeFilterOption;
  onChange: (filter: TimeFilterOption) => void;
}

const TimeFilter: React.FC<TimeFilterProps> = ({ selected, onChange }) => {
  const options: TimeFilterOption[] = ['1D', '1W', '1M', '3M', '1Y', 'ALL'];

  return (
    <div className="flex space-x-2">
      {options.map((period) => (
        <button
          key={period}
          onClick={() => onChange(period)}
          className={`px-3 py-1 text-sm rounded-full transition-colors ${
            selected === period 
              ? 'bg-green-600 text-white' 
              : 'text-gray-600 hover:bg-gray-100'
          }`}
        >
          {period}
        </button>
      ))}
    </div>
  );
};

export default TimeFilter;

// File: components/ui_module/frontend/src/utils/formatters.ts
// Type: ts

export const formatCurrency = (value: number): string => {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD',
      minimumFractionDigits: 0,
      maximumFractionDigits: 0,
    }).format(value);
  };
  
  export const formatDate = (dateString: string, includeTime: boolean = false): string => {
    const date = new Date(dateString);
    return new Intl.DateTimeFormat('en-US', {
      month: 'short',
      day: 'numeric',
      hour: includeTime ? 'numeric' : undefined,
      minute: includeTime ? 'numeric' : undefined,
    }).format(date);
  };

// File: components/ui_module/frontend/src/pages/Backtest.tsx
// Type: tsx

import React, { useState, useEffect } from 'react';
import BacktestConfigModal from '../components/BacktestConfigModal';

interface BacktestMetrics {
  strategy_name: string;
  ticker: string;
  start_date: string;
  end_date: string;
  cagr: number;
  total_return_pct: number;
  std_dev: number | null;
  annual_vol: number | null;
  sharpe_ratio: number | null;
  sortino_ratio: number | null;
  max_drawdown: number | null;
  win_rate: number | null;
  num_trades: number | null;
  information_ratio: number | null;
  strategy_unique_id: string;
}

const Backtest: React.FC = () => {
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [plotUrl, setPlotUrl] = useState<string | null>(null);
  const [backtestResults, setBacktestResults] = useState<BacktestMetrics[]>([]);

  // If you have an API endpoint that returns a list of previous backtests, you can fetch it here
  // If not, you can comment out this useEffect until you have that endpoint implemented.
  useEffect(() => {
    // Example: If you have /api/backtests returning { success: boolean, results: BacktestMetrics[] }
    fetch('/api/backtests')
      .then((res) => res.json())
      .then((data) => {
        if (data.success && Array.isArray(data.results)) {
          setBacktestResults(data.results);
        }
      })
      .catch((error) => {
        console.error('Error fetching backtests:', error);
      });
  }, []);

  const handleBacktestComplete = (url?: string, metrics?: BacktestMetrics) => {
    if (url) setPlotUrl(url);

    // If you want to re-fetch results after a backtest is completed:
    fetch('/api/backtests')
      .then((res) => res.json())
      .then((data) => {
        if (data.success && Array.isArray(data.results)) {
          setBacktestResults(data.results);
        }
      })
      .catch((error) => {
        console.error('Error fetching backtests after completion:', error);
      });

    // If you don't have an /api/backtests endpoint, just append the metrics to local state:
    // if (metrics) {
    //   setBacktestResults(prev => [...prev, metrics]);
    // }
  };

  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <h2 className="text-2xl font-bold text-gray-900">Backtest</h2>
        <button
          onClick={() => setIsModalOpen(true)}
          className="bg-indigo-600 text-white px-4 py-2 rounded-md hover:bg-indigo-700"
        >
          New Backtest
        </button>
      </div>

      <BacktestConfigModal
        isOpen={isModalOpen}
        onClose={() => setIsModalOpen(false)}
        onBacktestComplete={handleBacktestComplete}
      />

      <div className="bg-white shadow rounded-lg">
        <div className="p-6">
          <div className="flex space-x-4 mb-6">
            <button className="text-gray-600 hover:text-gray-900">Backtest Guide</button>
            <button className="text-gray-600 hover:text-gray-900">Custom Strategy</button>
            <button className="text-gray-600 hover:text-gray-900">Troubleshooting</button>
          </div>

          <div className="relative">
            <input
              type="text"
              placeholder="Search backtests..."
              className="w-full px-4 py-2 border border-gray-300 rounded-md"
            />
          </div>

          <table className="min-w-full mt-4">
            <thead>
              <tr>
                <th className="text-left">Date</th>
                <th className="text-left">Strategy</th>
                <th className="text-left">Symbol</th>
                <th className="text-left">Return</th>
                <th className="text-left">Trades</th>
              </tr>
            </thead>
            <tbody>
              {/* You can map a quick summary of backtests here if desired */}
            </tbody>
          </table>
        </div>
      </div>

      <h2 className="text-2xl font-bold text-gray-900">Backtest Results</h2>
      {plotUrl && (
        <div>
          <h3 className="text-lg font-medium text-gray-900 mb-4">Backtest Chart</h3>
          <img src={plotUrl} alt="Backtest Plot" className="border rounded shadow-lg max-w-full" />
        </div>
      )}

      {/* Scrollable table for all metrics */}
      <div className="overflow-x-auto border border-gray-200 rounded-lg">
        <table className="min-w-max text-sm text-left whitespace-nowrap">
          <thead className="bg-gray-50">
            <tr>
              <th className="px-4 py-2">Strategy Name</th>
              <th className="px-4 py-2">Ticker</th>
              <th className="px-4 py-2">Start Date</th>
              <th className="px-4 py-2">End Date</th>
              <th className="px-4 py-2">CAGR</th>
              <th className="px-4 py-2">Total Return %</th>
              <th className="px-4 py-2">Std Dev</th>
              <th className="px-4 py-2">Annual Vol</th>
              <th className="px-4 py-2">Sharpe Ratio</th>
              <th className="px-4 py-2">Sortino Ratio</th>
              <th className="px-4 py-2">Max Drawdown</th>
              <th className="px-4 py-2">Win Rate</th>
              <th className="px-4 py-2"># of Trades</th>
              <th className="px-4 py-2">Information Ratio</th>
              <th className="px-4 py-2">Strategy Unique ID</th>
            </tr>
          </thead>
          <tbody>
            {backtestResults.map((res, i) => (
              <tr key={i} className="border-t">
                <td className="px-4 py-2">{res.strategy_name}</td>
                <td className="px-4 py-2">{res.ticker}</td>
                <td className="px-4 py-2">{res.start_date}</td>
                <td className="px-4 py-2">{res.end_date}</td>
                <td className="px-4 py-2">{(res.cagr * 100).toFixed(2)}%</td>
                <td className="px-4 py-2">{res.total_return_pct.toFixed(2)}%</td>
                <td className="px-4 py-2">{res.std_dev !== null ? res.std_dev.toFixed(4) : 'N/A'}</td>
                <td className="px-4 py-2">{res.annual_vol !== null ? res.annual_vol.toFixed(4) : 'N/A'}</td>
                <td className="px-4 py-2">{res.sharpe_ratio !== null ? res.sharpe_ratio.toFixed(2) : 'N/A'}</td>
                <td className="px-4 py-2">{res.sortino_ratio !== null ? res.sortino_ratio.toFixed(2) : 'N/A'}</td>
                <td className="px-4 py-2">{res.max_drawdown !== null ? `${res.max_drawdown.toFixed(2)}%` : 'N/A'}</td>
                <td className="px-4 py-2">{res.win_rate !== null ? `${res.win_rate.toFixed(2)}%` : 'N/A'}</td>
                <td className="px-4 py-2">{res.num_trades !== null ? res.num_trades : 'N/A'}</td>
                <td className="px-4 py-2">{res.information_ratio !== null ? res.information_ratio.toFixed(2) : 'N/A'}</td>
                <td className="px-4 py-2">{res.strategy_unique_id}</td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>
    </div>
  );
};

export default Backtest;


// File: components/ui_module/frontend/src/pages/Dashboard.tsx
// Type: tsx

// File: components/ui_module/frontend/src/pages/Dashboard.tsx

import DashboardMetrics from '../components/dashboard/DashboardMetrics';
import DashboardChart from '../components/dashboard/DashboardChart';
import MarketOverview from '../components/dashboard/MarketOverview';
import React from 'react';

const Dashboard: React.FC = () => {
  return (
    <div className="space-y-6">
      {/* Stats Grid */}
      <DashboardMetrics />
      
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        {/* Portfolio Performance Card */}
        <div className="bg-white shadow rounded-lg p-6">
          <h3 className="text-sm font-medium text-gray-500">Portfolio Performance</h3>
          <DashboardChart />
        </div>

        {/* Market Overview */}
        <MarketOverview />
      </div>
    </div>
  );
};

export default Dashboard;


// File: components/ui_module/frontend/src/pages/DataManagement.tsx
// Type: tsx

import React, { useState } from 'react';

const DataManagement: React.FC = () => {
  const [newTicker, setNewTicker] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [message, setMessage] = useState<{type: 'success' | 'error', text: string} | null>(null);

  const handleAddTicker = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsLoading(true);
    setMessage(null);

    try {
      const response = await fetch('/api/tickers', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ ticker: newTicker.toUpperCase() }),
      });

      const data = await response.json();

      if (data.success) {
        setMessage({ type: 'success', text: `Successfully added ${newTicker.toUpperCase()}` });
        setNewTicker('');
      } else {
        setMessage({ type: 'error', text: data.message || 'Failed to add ticker' });
      }
    } catch (error) {
      setMessage({ type: 'error', text: 'Error connecting to server' });
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <h2 className="text-2xl font-bold text-gray-900">Data Management</h2>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        <div className="bg-white shadow rounded-lg p-6">
          <h3 className="text-lg font-medium text-gray-900 mb-4">Data Configuration</h3>
          <form className="space-y-4">
            <div>
              <label className="block text-sm font-medium text-gray-700">Data Interval</label>
              <select className="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                <option>5 Minutes</option>
                <option>15 Minutes</option>
                <option>1 Hour</option>
              </select>
            </div>
            <div>
              <label className="block text-sm font-medium text-gray-700">Historical Period</label>
              <select className="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                <option>5 Years</option>
              </select>
            </div>
            <button type="submit" className="bg-indigo-600 text-white px-4 py-2 rounded-md hover:bg-indigo-700">
              Update Configuration
            </button>
          </form>
        </div>

        <div className="bg-white shadow rounded-lg p-6">
          <h3 className="text-lg font-medium text-gray-900 mb-4">Data Status</h3>
          <div className="space-y-4">
            <div>
              <p className="text-sm text-gray-500">Last Update</p>
              <p className="font-medium">Never</p>
            </div>
            <div>
              <p className="text-sm text-gray-500">Stream Status</p>
              <span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-gray-100 text-gray-800">
                Inactive
              </span>
            </div>
          </div>
        </div>
      </div>

      <div className="bg-white shadow rounded-lg p-6">
        <h3 className="text-lg font-medium text-gray-900 mb-4">Add New Ticker</h3>
        <form onSubmit={handleAddTicker} className="space-y-4">
          <div>
            <label htmlFor="ticker" className="block text-sm font-medium text-gray-700">
              Ticker Symbol
            </label>
            <div className="mt-1 flex rounded-md shadow-sm">
              <input
                type="text"
                name="ticker"
                id="ticker"
                value={newTicker}
                onChange={(e) => setNewTicker(e.target.value)}
                className="flex-1 min-w-0 block w-full px-3 py-2 rounded-md border-gray-300 focus:ring-indigo-500 focus:border-indigo-500"
                placeholder="AAPL"
                maxLength={5}
              />
              <button
                type="submit"
                disabled={isLoading || !newTicker}
                className="ml-3 inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 disabled:opacity-50"
              >
                {isLoading ? 'Adding...' : 'Add Ticker'}
              </button>
            </div>
          </div>
          {message && (
            <div className={`mt-2 text-sm ${message.type === 'success' ? 'text-green-600' : 'text-red-600'}`}>
              {message.text}
            </div>
          )}
        </form>
      </div>
    </div>
  );
};

export default DataManagement;

// File: components/ui_module/frontend/src/pages/Portfolio.tsx
// Type: tsx

import React from 'react';
import CurrentPositions from '../components/portfolio/CurrentPositions';
import RecentTrades from '../components/portfolio/RecentTrades';

const Portfolio: React.FC = () => {
  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <h2 className="text-2xl font-bold text-gray-900">Portfolio</h2>
        <div className="space-x-4">
          <button className="bg-indigo-600 text-white px-4 py-2 rounded-md hover:bg-indigo-700">
            New Trade
          </button>
          <button className="bg-red-600 text-white px-4 py-2 rounded-md hover:bg-red-700">
            Emergency Liquidation
          </button>
        </div>
      </div>

      <div className="flex flex-col space-y-6">
        <div className="bg-white shadow rounded-lg p-6">
          <h3 className="text-lg font-medium text-gray-900 mb-4">Current Positions</h3>
          <CurrentPositions />
        </div>

        <div className="bg-white shadow rounded-lg p-6">
          <h3 className="text-lg font-medium text-gray-900 mb-4">Recent Trades</h3>
          <RecentTrades />
        </div>
      </div>
    </div>
  );
};

export default Portfolio;

// File: components/ui_module/frontend/src/pages/Settings.tsx
// Type: tsx

import React, { useState } from 'react';
import { ExclamationTriangleIcon } from '@heroicons/react/24/outline';

const Settings: React.FC = () => {
  const [apiKey, setApiKey] = useState('');
  const [apiSecret, setApiSecret] = useState('');
  const [environment, setEnvironment] = useState('paper');
  const [historicalPeriod, setHistoricalPeriod] = useState('5y');
  const [dataInterval, setDataInterval] = useState('5min');

  const handleSaveChanges = () => {
    // Implement save functionality
    console.log('Saving changes...');
  };

  const handleFileUpload = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (file) {
      console.log('File selected:', file.name);
    }
  };

  const handleDownloadTemplate = () => {
    // Implement template download
    console.log('Downloading template...');
  };

  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <h2 className="text-2xl font-bold text-gray-900">Data Settings</h2>
        <button
          onClick={handleSaveChanges}
          className="bg-indigo-600 text-white px-4 py-2 rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2"
        >
          Save Changes
        </button>
      </div>

      <div className="bg-white shadow rounded-lg p-6">
        <h3 className="text-lg font-medium text-gray-900 mb-6">API Configuration</h3>
        <div className="space-y-4">
          <div>
            <label htmlFor="apiKey" className="block text-sm font-medium text-gray-700">
              API Key
            </label>
            <input
              type="text"
              id="apiKey"
              value={apiKey}
              onChange={(e) => setApiKey(e.target.value)}
              placeholder="Enter your API key"
              className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50"
            />
          </div>
          <div>
            <label htmlFor="apiSecret" className="block text-sm font-medium text-gray-700">
              API Secret
            </label>
            <input
              type="password"
              id="apiSecret"
              value={apiSecret}
              onChange={(e) => setApiSecret(e.target.value)}
              placeholder="Enter your API secret"
              className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50"
            />
          </div>
          <div>
            <label htmlFor="environment" className="block text-sm font-medium text-gray-700">
              Environment
            </label>
            <select
              id="environment"
              value={environment}
              onChange={(e) => setEnvironment(e.target.value)}
              className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50"
            >
              <option value="paper">Paper Trading</option>
              <option value="live">Live Trading</option>
            </select>
          </div>
        </div>
      </div>

      <div className="bg-white shadow rounded-lg p-6">
        <h3 className="text-lg font-medium text-gray-900 mb-6">Data Settings</h3>
        <div className="space-y-4">
          <div>
            <label htmlFor="historicalPeriod" className="block text-sm font-medium text-gray-700">
              Historical Data Period
            </label>
            <select
              id="historicalPeriod"
              value={historicalPeriod}
              onChange={(e) => setHistoricalPeriod(e.target.value)}
              className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50"
            >
              <option value="5y">5 Years</option>
            </select>
          </div>
          <div>
            <label htmlFor="dataInterval" className="block text-sm font-medium text-gray-700">
              Data Interval
            </label>
            <select
              id="dataInterval"
              value={dataInterval}
              onChange={(e) => setDataInterval(e.target.value)}
              className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50"
            >
              <option value="5min">5 Minutes</option>
            </select>
          </div>
          <div>
            <label htmlFor="tickersFile" className="block text-sm font-medium text-gray-700">
              Tickers File
            </label>
            <div className="mt-1 flex items-center">
              <label className="relative flex-1">
                <input
                  type="file"
                  id="tickersFile"
                  onChange={handleFileUpload}
                  className="sr-only"
                  accept=".csv"
                />
                <div className="flex items-center justify-between px-4 py-2 border border-gray-300 rounded-md bg-white text-sm text-gray-700 hover:bg-gray-100 cursor-pointer">
                  <span>Choose File</span>
                </div>
              </label>
              <button
                onClick={handleDownloadTemplate}
                className="ml-4 text-indigo-600 hover:text-indigo-700 text-sm"
              >
                Download Template
              </button>
            </div>
          </div>
        </div>
      </div>

      <div className="rounded-md bg-yellow-50 p-4">
        <div className="flex">
          <div className="flex-shrink-0">
            <ExclamationTriangleIcon className="h-5 w-5 text-yellow-400" aria-hidden="true" />
          </div>
          <div className="ml-3">
            <p className="text-sm text-yellow-700">
              Changing these settings will require a full data resync. This process may take several minutes.
            </p>
          </div>
        </div>
      </div>
    </div>
  );
};

export default Settings;

// File: components/ui_module/frontend/src/pages/Strategy.tsx
// Type: tsx

// File: components/ui_module/frontend/src/pages/Strategy.tsx
import React, { useEffect, useState } from 'react';
import NewStrategyModal from '../components/NewStrategyModal';

// For storing the numeric fields in the main data
interface StrategyItem {
  name: string;
  mode: 'backtest' | 'live';
  allocation: number;    // e.g. 1234.56 means $1,234.56
  stop_loss: number;     // e.g. 0.05 => 5%
  take_profit: number;   // e.g. 0.1 => 10%
  tickers: string;       // plain text
}

function parseCurrency(str: string): number {
  const cleaned = str.replace(/[^0-9.\-]+/g, '');
  return parseFloat(cleaned) || 0;
}
function formatCurrency(val: number): string {
  return val.toLocaleString('en-US', {
    style: 'currency',
    currency: 'USD',
  });
}

function parsePercent(str: string): number {
  const cleaned = str.replace(/[^0-9.\-]+/g, '');
  return (parseFloat(cleaned) || 0) / 100;
}
function formatPercent(val: number): string {
  return (val * 100).toFixed(2) + '%';
}

const Strategy: React.FC = () => {
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [strategies, setStrategies] = useState<StrategyItem[]>([]);
  const [error, setError] = useState<string | null>(null);

  // --- Local ephemeral states for user-typing text (indexed by strategy row) ---
  // We store each numeric inputâ€™s typed text, so we can let the user type freely,
  // then parse/format on blur.
  const [localAllocations, setLocalAllocations] = useState<string[]>([]);
  const [localStopLosses, setLocalStopLosses] = useState<string[]>([]);
  const [localTakeProfits, setLocalTakeProfits] = useState<string[]>([]);

  useEffect(() => {
    fetch('/api/strategies')
      .then((res) => res.json())
      .then((data) => {
        if (!data.success) {
          setError(data.message || 'Failed to fetch strategies');
          return;
        }

        // Convert backend data to numeric fields
        const loaded: StrategyItem[] = data.data.map((s: any) => ({
          name: s.name,
          mode: s.mode,
          allocation: s.allocation ? parseFloat(s.allocation) : 0,
          stop_loss: s.stop_loss ? parseFloat(s.stop_loss) : 0,
          take_profit: s.take_profit ? parseFloat(s.take_profit) : 0,
          tickers: s.tickers || '',
        }));

        setStrategies(loaded);

        // Initialize ephemeral text states with a formatted string
        setLocalAllocations(
          loaded.map((st) => formatCurrency(st.allocation))
        );
        setLocalStopLosses(
          loaded.map((st) => formatPercent(st.stop_loss))
        );
        setLocalTakeProfits(
          loaded.map((st) => formatPercent(st.take_profit))
        );
      })
      .catch((err) => {
        setError('Error fetching strategies');
        console.error(err);
      });
  }, []);

  // Handler for Tickers can remain in the main strategies array
  const handleTickersChange = (index: number, newVal: string) => {
    setStrategies((prev) => {
      const copy = [...prev];
      copy[index] = { ...copy[index], tickers: newVal };
      return copy;
    });
  };

  // ========== ALLOCATION INPUTS ==========
  const handleAllocationChange = (index: number, newText: string) => {
    // user is typing text freely
    setLocalAllocations((prev) => {
      const copy = [...prev];
      copy[index] = newText;
      return copy;
    });
  };
  const handleAllocationBlur = (index: number) => {
    // parse typed => numeric => store in strategies
    const rawNum = parseCurrency(localAllocations[index]);
    setStrategies((prev) => {
      const copy = [...prev];
      copy[index].allocation = rawNum;
      return copy;
    });
    // also reformat ephemeral text
    setLocalAllocations((prev) => {
      const copy = [...prev];
      copy[index] = formatCurrency(rawNum);
      return copy;
    });
  };
  const handleAllocationFocus = (index: number) => {
    // On focus, show plain numeric to user
    const rawNum = parseCurrency(localAllocations[index]);
    setLocalAllocations((prev) => {
      const copy = [...prev];
      copy[index] = String(rawNum || '');
      return copy;
    });
  };

  // ========== STOP LOSS INPUTS ==========
  const handleStopLossChange = (index: number, newText: string) => {
    setLocalStopLosses((prev) => {
      const copy = [...prev];
      copy[index] = newText;
      return copy;
    });
  };
  const handleStopLossBlur = (index: number) => {
    const val = parsePercent(localStopLosses[index]);
    setStrategies((prev) => {
      const copy = [...prev];
      copy[index].stop_loss = val;
      return copy;
    });
    setLocalStopLosses((prev) => {
      const copy = [...prev];
      copy[index] = formatPercent(val);
      return copy;
    });
  };
  const handleStopLossFocus = (index: number) => {
    const val = parsePercent(localStopLosses[index]);
    setLocalStopLosses((prev) => {
      const copy = [...prev];
      copy[index] = String(val * 100 || '');
      return copy;
    });
  };

  // ========== TAKE PROFIT INPUTS ==========
  const handleTakeProfitChange = (index: number, newText: string) => {
    setLocalTakeProfits((prev) => {
      const copy = [...prev];
      copy[index] = newText;
      return copy;
    });
  };
  const handleTakeProfitBlur = (index: number) => {
    const val = parsePercent(localTakeProfits[index]);
    setStrategies((prev) => {
      const copy = [...prev];
      copy[index].take_profit = val;
      return copy;
    });
    setLocalTakeProfits((prev) => {
      const copy = [...prev];
      copy[index] = formatPercent(val);
      return copy;
    });
  };
  const handleTakeProfitFocus = (index: number) => {
    const val = parsePercent(localTakeProfits[index]);
    setLocalTakeProfits((prev) => {
      const copy = [...prev];
      copy[index] = String(val * 100 || '');
      return copy;
    });
  };

  // Toggle mode => PATCH request
  const handleToggleMode = (index: number) => {
    const strat = strategies[index];
    const newMode = strat.mode === 'backtest' ? 'live' : 'backtest';

    fetch(`/api/strategies/${strat.name}`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        mode: newMode,
        allocation: strat.allocation,
        stop_loss: strat.stop_loss,
        take_profit: strat.take_profit,
        tickers: strat.tickers,
      }),
    })
      .then((res) => res.json())
      .then((data) => {
        if (!data.success) {
          setError(data.message || 'Failed to update strategy');
          return;
        }
        // locally update mode
        setStrategies((prev) => {
          const copy = [...prev];
          copy[index] = { ...copy[index], mode: newMode };
          return copy;
        });
      })
      .catch((err) => {
        setError('Network error updating strategy mode');
        console.error(err);
      });
  };

  const handleOpenModal = () => setIsModalOpen(true);

  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <h2 className="text-2xl font-bold text-gray-900">Strategy Management</h2>
        <button
          onClick={handleOpenModal}
          className="bg-indigo-600 text-white px-4 py-2 rounded-md hover:bg-indigo-700"
        >
          Add Strategy
        </button>
      </div>

      {error && <div className="text-red-600">{error}</div>}

      <div className="hidden">Modal state: {isModalOpen ? 'open' : 'closed'}</div>

      <NewStrategyModal
        isOpen={isModalOpen}
        onClose={() => setIsModalOpen(false)}
      />

      <div className="bg-white shadow rounded-lg">
        <div className="p-6">
          <h3 className="text-lg font-medium text-gray-900 mb-4">
            Available Strategies
          </h3>
          {strategies.length === 0 ? (
            <div className="text-gray-500">No strategies configured</div>
          ) : (
            <ul className="space-y-4">
              {strategies.map((strat, i) => (
                <li key={strat.name} className="bg-gray-50 p-3 rounded">
                  <div className="grid grid-cols-1 gap-2">
                    <div className="text-lg font-semibold">
                      {strat.name}
                    </div>
                    <div className="grid grid-cols-5 items-center gap-4">
                      {/* Allocation */}
                      <div className="flex items-center space-x-2">
                        <label className="whitespace-nowrap">Allocation:</label>
                        <input
                          type="text"
                          className="border px-1 py-0.5 w-24"
                          onFocus={() => handleAllocationFocus(i)}
                          onBlur={() => handleAllocationBlur(i)}
                          onChange={(e) =>
                            handleAllocationChange(i, e.target.value)
                          }
                          value={localAllocations[i] ?? ''}
                        />
                      </div>

                      {/* Stop Loss */}
                      <div className="flex items-center space-x-2">
                        <label className="whitespace-nowrap">Stop Loss:</label>
                        <input
                          type="text"
                          className="border px-1 py-0.5 w-20"
                          onFocus={() => handleStopLossFocus(i)}
                          onBlur={() => handleStopLossBlur(i)}
                          onChange={(e) =>
                            handleStopLossChange(i, e.target.value)
                          }
                          value={localStopLosses[i] ?? ''}
                        />
                      </div>

                      {/* Take Profit */}
                      <div className="flex items-center space-x-2">
                        <label className="whitespace-nowrap">Take Profit:</label>
                        <input
                          type="text"
                          className="border px-1 py-0.5 w-20"
                          onFocus={() => handleTakeProfitFocus(i)}
                          onBlur={() => handleTakeProfitBlur(i)}
                          onChange={(e) =>
                            handleTakeProfitChange(i, e.target.value)
                          }
                          value={localTakeProfits[i] ?? ''}
                        />
                      </div>

                      {/* Tickers */}
                      <div className="flex items-center space-x-2">
                        <label className="whitespace-nowrap">Tickers:</label>
                        <input
                          type="text"
                          className="border px-1 py-0.5 w-32"
                          placeholder="AAPL,TSLA"
                          value={strat.tickers}
                          onChange={(e) =>
                            handleTickersChange(i, e.target.value)
                          }
                        />
                      </div>

                      {/* Toggle Mode */}
                      <div className="justify-self-end">
                        <button
                          className={`px-3 py-1 rounded-md ${
                            strat.mode === 'live'
                              ? 'bg-green-600 text-white'
                              : 'bg-gray-300 text-black'
                          }`}
                          onClick={() => handleToggleMode(i)}
                        >
                          {strat.mode === 'live'
                            ? 'Switch to Backtest'
                            : 'Switch to Live'}
                        </button>
                      </div>
                    </div>
                  </div>
                </li>
              ))}
            </ul>
          )}
        </div>
      </div>
    </div>
  );
};

export default Strategy;


// File: components/ui_module/frontend/src/pages/index.ts
// Type: ts

export { default as Dashboard } from './Dashboard';
export { default as Strategy } from './Strategy';
export { default as Backtest } from './Backtest';
export { default as Portfolio } from './Portfolio';
export { default as DataManagement } from './DataManagement';
export { default as Settings } from './Settings';

# File: components/ui_module/backend/app.py
# Type: py

# File: components/ui_module/backend/app.py

from flask import Flask, jsonify, request
from flask_cors import CORS
import os
import sys
import logging
import pandas as pd
import zmq
import json
from pathlib import Path
import traceback
from datetime import datetime, timedelta
from alpaca_trade_api.rest import REST
import os
import logging
import requests
from flask import jsonify
import pytz
import sqlite3



current_dir = os.path.dirname(os.path.abspath(__file__))
project_root = os.path.abspath(os.path.join(current_dir, '..', '..', '..'))

# Insert the project_root at the start of sys.path
if project_root not in sys.path:
    sys.path.insert(0, project_root)

    

# Configure logging with more detailed formatting
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(sys.stdout),
        logging.FileHandler('flask_app.log')
    ]
)
logger = logging.getLogger(__name__)

# Add the project root to the Python path
current_dir = os.path.dirname(os.path.abspath(__file__))
project_root = os.path.dirname(os.path.dirname(os.path.dirname(current_dir)))
if project_root not in sys.path:
    sys.path.insert(0, project_root)
    
    
    
from components.backtesting_module.backtrader.strategy_adapters import StrategyAdapter


# DB_PATH = os.path.join(os.path.dirname(__file__), '..', '..', 'data', 'backtesting_results.db')
DB_PATH = os.path.join(project_root, 'data', 'backtesting_results.db')

def initialize_db():
    """
    Ensures the 'strategies' table exists and all needed columns are present.
    """
    conn = sqlite3.connect(DB_PATH)
    cur = conn.cursor()

    # Basic table creation
    cur.execute('''
        CREATE TABLE IF NOT EXISTS strategies (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT UNIQUE,
            mode TEXT DEFAULT 'backtest' CHECK(mode IN ('backtest','live')),
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP
        )
    ''')

    # NEW: Try adding columns if they don't already exist
    new_columns = [
        ("allocation",    "REAL",  "0.0"),
        ("tickers",       "TEXT",  "'[]'"),
        ("stop_loss",     "REAL",  "0.0"),
        ("take_profit",   "REAL",  "0.0"),
    ]
    for col_name, col_type, default_val in new_columns:
        try:
            cur.execute(f"ALTER TABLE strategies ADD COLUMN {col_name} {col_type} DEFAULT {default_val}")
        except sqlite3.OperationalError:
            pass  # Column likely exists

    conn.commit()
    conn.close()
    
    

# ZeroMQ configuration for communication with data manager
class DataManagerClient:
    def __init__(self):
        self.context = zmq.Context.instance()
        self.socket = self.context.socket(zmq.REQ)
        self.socket.connect("tcp://localhost:5556")
        self.socket.setsockopt(zmq.RCVTIMEO, 5000)  # 5 second timeout
        self.socket.setsockopt(zmq.LINGER, 0)
        logger.info("DataManagerClient initialized with socket connection to localhost:5556")

    def send_command(self, command):
        try:
            logger.info(f"Attempting to send command: {command}")
            logger.debug(f"ZMQ socket state - Connected: {self.socket}")
            
            self.socket.send_json(command)
            logger.info("Command sent successfully, waiting for response")
            
            response = self.socket.recv_json()
            logger.info(f"Received response: {response}")
            return response
            
        except zmq.error.Again:
            logger.error(f"""
            Timeout waiting for response from data manager
            Command: {command}
            Socket Details:
            - Type: {self.socket.type}
            - Endpoint: tcp://localhost:5556
            """)
            return {"success": False, "message": "Command timeout"}
        except Exception as e:
            logger.error(f"Error sending command to data manager: {str(e)}\nTraceback: {traceback.format_exc()}")
            return {"success": False, "message": str(e)}

    def close(self):
        self.socket.close()

app = Flask(__name__)
CORS(app)

# Initialize the data manager client
data_manager_client = DataManagerClient()

def get_tickers_file_path():
    """Get the absolute path to the tickers.csv file"""
    return os.path.join(project_root, 'data', 'tickers.csv')

def log_request_info(request):
    logger.debug(f"""
    Request Details:
    - Method: {request.method}
    - URL: {request.url}
    - Headers: {dict(request.headers)}
    - Body: {request.get_data()}
    """)

@app.route('/api/tickers', methods=['GET'])
def get_tickers():
    """Endpoint to get list of tickers"""
    try:
        tickers_file = get_tickers_file_path()
        if not os.path.exists(tickers_file):
            logger.error(f"Tickers file not found at: {tickers_file}")
            return jsonify({
                'success': False,
                'message': 'Tickers file not found'
            }), 404

        tickers_df = pd.read_csv(tickers_file, names=['ticker'])
        return jsonify({
            'success': True,
            'tickers': tickers_df['ticker'].tolist()
        })
    except Exception as e:
        logger.error(f"Error fetching tickers: {str(e)}")
        return jsonify({
            'success': False,
            'message': str(e)
        }), 500

@app.route('/api/tickers', methods=['POST'])
def add_ticker():
    """Endpoint to add a new ticker"""
    try:
        log_request_info(request)
        logger.info("Received request to add ticker")
        
        data = request.get_json()
        logger.debug(f"Received data: {data}")
        
        if not data or 'ticker' not in data:
            logger.warning("No ticker provided in request")
            return jsonify({
                'success': False,
                'message': 'No ticker provided'
            }), 400

        ticker = data['ticker'].upper()
        logger.info(f"Processing ticker: {ticker}")
        
        # Validate ticker format
        if not ticker.isalpha() or not (1 <= len(ticker) <= 5):
            return jsonify({
                'success': False,
                'message': 'Invalid ticker format'
            }), 400

        # Send command to data manager
        response = data_manager_client.send_command({
            'type': 'add_ticker',
            'ticker': ticker
        })

        if response.get('success'):
            return jsonify({
                'success': True,
                'message': f'Ticker {ticker} added successfully'
            })
        else:
            return jsonify({
                'success': False,
                'message': response.get('message', 'Failed to add ticker')
            }), 500

    except Exception as e:
        logger.error(f"Error adding ticker: {str(e)}")
        return jsonify({
            'success': False,
            'message': str(e)
        }), 500

@app.route('/health', methods=['GET'])
def health_check():
    """Endpoint to check if the service is running"""
    return jsonify({
        'status': 'healthy',
        'timestamp': pd.Timestamp.now().isoformat()
    })

@app.errorhandler(404)
def not_found(error):
    return jsonify({
        'success': False,
        'message': 'Endpoint not found'
    }), 404

@app.errorhandler(500)
def internal_error(error):
    return jsonify({
        'success': False,
        'message': 'Internal server error'
    }), 500


def seed_built_in_strategies():
    # We avoid duplicating code; just do an upsert-like approach
    built_in_strategies = list(StrategyAdapter.STRATEGIES.keys())

    conn = sqlite3.connect(DB_PATH)
    cur = conn.cursor()
    for strat_name in built_in_strategies:
        cur.execute('''
            INSERT INTO strategies (name)
            VALUES (?)
            ON CONFLICT(name) DO NOTHING
        ''', (strat_name,))
    conn.commit()
    conn.close()

def initialize_app():
    """Initialize the application with required setup"""
    try:
        # Initialize database and seed strategies
        initialize_db()
        seed_built_in_strategies()
        
        # Ensure tickers file exists
        tickers_file = get_tickers_file_path()
        if not os.path.exists(tickers_file):
            Path(tickers_file).parent.mkdir(parents=True, exist_ok=True)
            pd.DataFrame(columns=['ticker']).to_csv(tickers_file, index=False)
            logger.info(f"Created new tickers file at {tickers_file}")

        logger.info("Flask application initialized successfully")
    except Exception as e:
        logger.error(f"Error initializing application: {str(e)}")
        raise


@app.route('/api/positions', methods=['GET'])
def get_positions():
    """Endpoint to get current positions from Alpaca"""
    try:
        logger.info("Attempting to fetch positions")
        
        # Alpaca API configuration
        url = "https://paper-api.alpaca.markets/v2/positions"
        headers = {
            "accept": "application/json",
            "APCA-API-KEY-ID": os.getenv('APCA_API_KEY_ID'),
            "APCA-API-SECRET-KEY": os.getenv('APCA_API_SECRET_KEY')
        }
        
        # Make the request
        response = requests.get(url, headers=headers)
        response.raise_for_status()  # Raise an error for bad status codes
        
        # Parse the response
        positions = response.json()
        
        # Format positions data
        positions_data = [{
            'symbol': pos['symbol'],
            'qty': float(pos['qty']),
            'avgEntryPrice': float(pos['avg_entry_price']),
            'marketValue': float(pos['market_value']),
            'currentPrice': float(pos['current_price']),
            'unrealizedPL': float(pos['unrealized_pl']),
            'unrealizedPLPercent': float(pos['unrealized_plpc']),
            'change': float(pos['change_today'])
        } for pos in positions]
        
        logger.info(f"Successfully retrieved {len(positions_data)} positions")
        return jsonify({
            'success': True,
            'positions': positions_data
        })
        
    except requests.exceptions.RequestException as e:
        logger.error(f"Error fetching positions from Alpaca: {str(e)}")
        return jsonify({
            'success': False,
            'message': f"API error: {str(e)}"
        }), 500
    except Exception as e:
        logger.error(f"Error processing positions data: {str(e)}")
        return jsonify({
            'success': False,
            'message': str(e)
        }), 500    

@app.route('/api/recent-trades', methods=['GET'])
def get_recent_trades():
    """Endpoint to get recent trades from Alpaca"""
    try:
        logger.info("Attempting to fetch recent trades")
        
        base_url = "https://paper-api.alpaca.markets"
        endpoint = "/v2/account/activities/FILL"
        
        headers = {
            "APCA-API-KEY-ID": os.getenv('APCA_API_KEY_ID'),
            "APCA-API-SECRET-KEY": os.getenv('APCA_API_SECRET_KEY'),
            "accept": "application/json"
        }
        
        params = {
            "direction": "desc",  # Most recent first
            "page_size": 20      # Limit to 15 trades
        }
        
        logger.info("Making request to Alpaca API")
        response = requests.get(
            f"{base_url}{endpoint}", 
            headers=headers,
            params=params
        )
        
        response.raise_for_status()
        trades = response.json()
        
        logger.info(f"Retrieved {len(trades)} trades")
        
        # Format the trade data for frontend consumption
        formatted_trades = []
        for trade in trades:
            formatted_trade = {
                'symbol': trade['symbol'],
                'side': trade['side'],
                'qty': float(trade['qty']),
                'price': float(trade['price']),
                'time': trade['transaction_time'],
                'order_id': trade['order_id'],
                'total_value': float(trade['qty']) * float(trade['price'])
            }
            formatted_trades.append(formatted_trade)
        
        logger.info("Successfully formatted trade data")
        return jsonify({
            'success': True,
            'trades': formatted_trades
        })
        
    except requests.exceptions.RequestException as e:
        logger.error(f"Error fetching trades from Alpaca: {str(e)}")
        return jsonify({
            'success': False,
            'message': f"API error: {str(e)}"
        }), 500
    except Exception as e:
        logger.error(f"Unexpected error processing trades: {str(e)}")
        return jsonify({
            'success': False,
            'message': str(e)
        }), 500



# Create console handler and set level to DEBUG
ch = logging.StreamHandler()
ch.setLevel(logging.DEBUG)

# Create formatter and add it to the handler
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
ch.setFormatter(formatter)

# Add the handler to the logger
logger.addHandler(ch)


@app.route('/api/portfolio/history', methods=['GET'])
def get_portfolio_history():
    """Get historical portfolio value data based on time period"""
    try:
        # Get time period from query parameter (default to 1M)
        period = request.args.get('period', '1M')
        
        # Convert period to Alpaca's format (Y -> 12M)
        if period == '1Y':
            period = '12M'
        elif period == 'ALL':
            period = '60M'  # 5 years
        
        # Configure Alpaca API request
        base_url = "https://paper-api.alpaca.markets"
        headers = {
            "APCA-API-KEY-ID": os.getenv('APCA_API_KEY_ID'),
            "APCA-API-SECRET-KEY": os.getenv('APCA_API_SECRET_KEY'),
            "accept": "application/json"
        }
        
        # Set proper timeframe based on period according to Alpaca's rules
        params = {
            'extended_hours': 'true'
        }
        
        # Map timeframes based on period
        if period == '1D':
            params['timeframe'] = '5Min'
        elif period == '1W':
            params['timeframe'] = '15Min'
        else:
            params['timeframe'] = '1D'  # Use 1D for all longer periods
        
        # Add period parameter
        params['period'] = period
        
        logger.info(f"Requesting portfolio history with params: {params}")
        
        response = requests.get(
            f"{base_url}/v2/account/portfolio/history",
            headers=headers,
            params=params
        )
        
        if not response.ok:
            logger.error(f"Alpaca API error response: {response.text}")
            response.raise_for_status()
            
        history_data = response.json()
        
        # Process and format data for frontend
        timestamps = history_data.get('timestamp', [])
        equity = history_data.get('equity', [])
        base_value = history_data.get('base_value', 0)
        
        formatted_data = []
        est_tz = pytz.timezone('America/New_York')
        
        for timestamp, value in zip(timestamps, equity):
            if value is not None:  # Skip any null values
                dt = datetime.fromtimestamp(timestamp, pytz.UTC)
                dt_est = dt.astimezone(est_tz)
                formatted_data.append({
                    'date': dt_est.isoformat(),
                    'value': float(value)
                })
        
        # Calculate percentage change using base_value from Alpaca if available
        if len(formatted_data) >= 2:
            start_value = base_value if base_value else formatted_data[0]['value']
            end_value = formatted_data[-1]['value']
            percentage_change = ((end_value - start_value) / start_value) * 100 if start_value else 0
        else:
            percentage_change = 0
            
        response_data = {
            'success': True,
            'data': {
                'history': formatted_data,
                'currentBalance': formatted_data[-1]['value'] if formatted_data else 0,
                'percentageChange': round(percentage_change, 2)
            }
        }
        
        return jsonify(response_data)
        
    except requests.exceptions.RequestException as e:
        error_details = e.response.text if hasattr(e, 'response') else 'No response details'
        logger.error(f"Alpaca API error response: {error_details}")
        logger.error(f"Error fetching portfolio history from Alpaca: {str(e)}")
        logger.error(f"Full error details: {error_details}")
        return jsonify({
            'success': False,
            'message': f"API error: {str(e)}"
        }), 500
    except Exception as e:
        logger.error(f"Error processing portfolio history: {str(e)}")
        logger.error(f"Full traceback: {traceback.format_exc()}")
        return jsonify({
            'success': False,
            'message': str(e)
        }), 500
        
        
@app.route('/api/dashboard-data', methods=['GET'])
def get_dashboard_data():
    """Endpoint to get dashboard metrics from Alpaca"""
    try:
        # Base URL for paper trading
        base_url = "https://paper-api.alpaca.markets"
        headers = {
            "APCA-API-KEY-ID": os.getenv('APCA_API_KEY_ID'),
            "APCA-API-SECRET-KEY": os.getenv('APCA_API_SECRET_KEY'),
            "accept": "application/json"
        }
        
        # Get account info
        account_response = requests.get(
            f"{base_url}/v2/account",
            headers=headers
        )
        account_response.raise_for_status()
        account = account_response.json()
        
        # Calculate metrics
        equity = float(account.get('equity', 0))
        cash = float(account.get('cash', 0))
        last_equity = float(account.get('last_equity', equity))
        today_pl = equity - last_equity
        today_return = (today_pl / last_equity) * 100 if last_equity != 0 else 0
        
        return jsonify({
            'success': True,
            'data': {
                'account_balance': equity,
                'cash_available': cash,
                'today_pl': today_pl,
                'today_return': today_return
            }
        })
        
    except requests.exceptions.RequestException as e:
        logger.error(f"Error fetching account data from Alpaca: {str(e)}")
        return jsonify({
            'success': False,
            'message': f"API error: {str(e)}"
        }), 500
    except Exception as e:
        logger.error(f"Error fetching dashboard data: {str(e)}")
        return jsonify({
            'success': False,
            'message': str(e)
        }), 500
        

from flask import Flask, jsonify
from flask_cors import CORS
import os
import logging
import requests
from datetime import datetime
import pytz
from typing import Dict, List, Optional, Union

# # Configure logging
# logging.basicConfig(
#     level=logging.INFO,
#     format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
# )
# logger = logging.getLogger(__name__)

# app = Flask(__name__)
# CORS(app)

# Market symbols configuration
MARKET_SYMBOLS = {
    'SPY': "S&P 500",
    'QQQ': "NASDAQ",
    'IWV': "Russell 3000",
    'GLD': "Gold",
    'VXX': "VIX",
    'EWJ': "Japan (XJPX Proxy)",
    'EWU': "UK (XLON Proxy)",
    'BTC/USD': "Bitcoin"
}

class MarketData:
    def __init__(self):
        self.base_url = "https://data.alpaca.markets"
        self.headers = {
            "APCA-API-KEY-ID": os.getenv('APCA_API_KEY_ID', ''),
            "APCA-API-SECRET-KEY": os.getenv('APCA_API_SECRET_KEY', ''),
            "accept": "application/json"
        }

    def get_stock_data(self, symbol: str) -> Optional[Dict]:
        """Get current price and previous close for a stock."""
        try:
            # Get latest price from snapshot
            snapshot_resp = requests.get(
                f"{self.base_url}/v2/stocks/{symbol}/snapshot",
                headers=self.headers,
                params={"feed": "sip"}
            )
            snapshot_resp.raise_for_status()
            snapshot_data = snapshot_resp.json()
            current_price = snapshot_data.get('latestTrade', {}).get('p')
            prev_close = snapshot_data.get('prevDailyBar', {}).get('c')

            return {
                'current_price': current_price,
                'prev_close': prev_close
            }
        except Exception as e:
            logger.error(f"Error fetching stock data for {symbol}: {e}")
            return None

    def get_crypto_data(self, symbol: str) -> Optional[Dict]:
        """Get current price and previous close for crypto."""
        try:
            # Get latest trade
            trade_resp = requests.get(
                f"{self.base_url}/v1beta3/crypto/us/latest/trades",
                headers=self.headers,
                params={"symbols": symbol}
            )
            trade_resp.raise_for_status()
            current_price = trade_resp.json().get('trades', {}).get(symbol, {}).get('p')

            # Get previous day's close
            bars_resp = requests.get(
                f"{self.base_url}/v1beta3/crypto/us/bars",
                headers=self.headers,
                params={
                    "symbols": symbol,
                    "timeframe": "1Day",
                    "limit": 2
                }
            )
            bars_resp.raise_for_status()
            bars = bars_resp.json().get('bars', {}).get(symbol, [])
            prev_close = bars[0].get('c') if bars else None

            return {
                'current_price': current_price,
                'prev_close': prev_close
            }
        except Exception as e:
            logger.error(f"Error fetching crypto data for {symbol}: {e}")
            return None

    @staticmethod
    def calculate_change(current: float, previous: float) -> float:
        """Calculate percentage change between two values."""
        if not (current and previous and previous != 0):
            return 0.0
        return ((current - previous) / previous) * 100

@app.route('/api/market-overview', methods=['GET'])
def market_overview():
    """Get market overview data for all tracked symbols."""
    try:
        market_data = []
        market_service = MarketData()

        for symbol, name in MARKET_SYMBOLS.items():
            try:
                # Get price data based on symbol type
                if symbol == 'BTC/USD':
                    data = market_service.get_crypto_data(symbol)
                else:
                    data = market_service.get_stock_data(symbol)

                if data and data['current_price']:
                    # Calculate change and format price
                    change = market_service.calculate_change(
                        data['current_price'], 
                        data['prev_close']
                    )
                    
                    market_data.append({
                        'symbol': symbol,
                        'name': name,
                        'price': f"{data['current_price']:,.2f}",
                        'change': round(change, 2)
                    })
                else:
                    # Add placeholder data if fetch failed
                    market_data.append({
                        'symbol': symbol,
                        'name': name,
                        'price': 'N/A',
                        'change': 0.0
                    })

            except Exception as e:
                logger.error(f"Error processing {symbol}: {e}")
                # Maintain symbol visibility even on error
                market_data.append({
                    'symbol': symbol,
                    'name': name,
                    'price': 'N/A',
                    'change': 0.0
                })

        # Sort market data by symbol
        market_data.sort(key=lambda x: x['symbol'])
        
        return jsonify({
            'success': True,
            'data': market_data
        })

    except Exception as e:
        logger.error(f"General error in market overview: {e}")
        return jsonify({
            'success': False,
            'message': str(e)
        }), 500

# @app.route('/api/backtest/strategies', methods=['GET'])
# def get_available_strategies():
#     from components.backtesting_module.backtrader.strategy_adapters import StrategyAdapter
#     # StrategyAdapter.STRATEGIES is a dict { 'Name': StrategyClass, ... }
#     strategies = list(StrategyAdapter.STRATEGIES.keys())
#     return jsonify({
#         'success': True,
#         'strategies': strategies
#     })

@app.route('/api/backtest/strategies', methods=['GET'])
def get_available_strategies():
    from components.backtesting_module.backtrader.strategy_adapters import StrategyAdapter
    strategies = list(StrategyAdapter.STRATEGIES.keys())
    return jsonify({'success': True, 'strategies': strategies})

@app.route('/api/backtest/run', methods=['POST'])
def run_backtest():
    from components.backtesting_module.backtester import Backtester
    data = request.get_json()
    strategy_name = data.get('strategy')
    symbol = data.get('symbol')
    start_date = data.get('start_date')
    end_date = data.get('end_date')
    # Optional parameters
    stop_loss = data.get('stop_loss')
    take_profit = data.get('take_profit')

    try:
        start_dt = pd.to_datetime(start_date)
        end_dt = pd.to_datetime(end_date)

        # If strategy parameters are passed, extract them:
        # strategy_params = data.get('strategy_params', {})
        strategy_params = {}  # For now, empty or fill as needed.

        backtester = Backtester(
            strategy_name=strategy_name,
            strategy_params=strategy_params,
            ticker=symbol,
            start_date=start_dt,
            end_date=end_dt,
            db_path=os.path.join(project_root, 'data', 'market_data.db'),
            stop_loss=stop_loss,
            take_profit=take_profit
        )
        backtester.run_backtest()

        # Retrieve the metrics we just saved from the database
        conn = sqlite3.connect(os.path.join(project_root, 'data', 'backtesting_results.db'))
        cursor = conn.cursor()

        # Get the most recent backtest record for this strategy/ticker/date combination
        cursor.execute('''
            SELECT strategy_name, ticker, start_date, end_date, cagr, total_pct_change, std_dev, annual_vol, sharpe_ratio,
                   sortino_ratio, max_drawdown, win_rate, num_trades, information_ratio, strategy_unique_id
            FROM backtest_summary
            WHERE strategy_name = ? AND ticker = ? AND start_date = ? AND end_date = ?
            ORDER BY id DESC LIMIT 1
        ''', (strategy_name, symbol, start_dt.strftime('%Y-%m-%d %H:%M:%S'), end_dt.strftime('%Y-%m-%d %H:%M:%S')))
        row = cursor.fetchone()
        conn.close()

        if row:
            # Extract metrics
            metrics = {
                'strategy_name': row[0],
                'ticker': row[1],
                'start_date': row[2],
                'end_date': row[3],
                'cagr': row[4],
                'total_return_pct': row[5],
                'std_dev': row[6],
                'annual_vol': row[7],
                'sharpe_ratio': row[8],
                'sortino_ratio': row[9],
                'max_drawdown': row[10],
                'win_rate': row[11],
                'num_trades': row[12],
                'information_ratio': row[13],
                'strategy_unique_id': row[14]
            }
        else:
            metrics = None

        # Return the plot_url if we have it
        plot_filename = getattr(backtester, 'plot_filename', None)
        plot_url = None
        if plot_filename:
            plot_url = '/' + plot_filename.replace('\\', '/').lstrip('/')

        return jsonify({
            'success': True,
            'message': 'Backtest completed successfully',
            'plot_url': plot_url,
            'metrics': metrics  # Return the metrics we just fetched
        })

    except Exception as e:
        return jsonify({
            'success': False,
            'message': str(e)
        }), 500


@app.route('/api/backtests', methods=['GET'])
def get_all_backtests():
    import sqlite3, json
    conn = sqlite3.connect(os.path.join(project_root, 'data', 'backtesting_results.db'))
    cursor = conn.cursor()
    cursor.execute("""
        SELECT
            id,
            strategy_name,
            strategy_params,
            ticker,
            start_date,
            end_date,
            final_value,
            total_pl,
            total_pct_change,
            cagr,
            total_return,
            std_dev,
            annual_vol,
            sharpe_ratio,
            sortino_ratio,
            max_drawdown,
            win_rate,
            alpha,
            num_trades,
            information_ratio,
            strategy_unique_id,
            timestamp
        FROM backtest_summary
        ORDER BY timestamp DESC
    """)
    rows = cursor.fetchall()
    conn.close()

    results = []
    for row in rows:
        strategy_params = json.loads(row[2]) if row[2] else {}
        result = {
            'id': row[0],
            'strategy_name': row[1],
            'strategy_params': strategy_params,
            'ticker': row[3],
            'start_date': row[4],
            'end_date': row[5],
            'final_value': row[6],
            'total_pl': row[7],
            'total_return_pct': row[8],  # Changed from 'total_pct_change' to 'total_return_pct'
            'cagr': row[9],
            'total_return': row[10],
            'std_dev': row[11],
            'annual_vol': row[12],
            'sharpe_ratio': row[13],
            'sortino_ratio': row[14],
            'max_drawdown': row[15],
            'win_rate': row[16],
            'alpha': row[17],
            'num_trades': row[18],
            'information_ratio': row[19],
            'strategy_unique_id': row[20],
            'timestamp': row[21]
        }
        results.append(result)
    return jsonify({'success': True, 'results': results})


# @app.route('/api/strategies', methods=['GET'])
# def get_all_strategies():
#     """
#     Returns all strategy names and their mode, e.g. [ { name: 'MyStrat', mode: 'live' }, ... ]
#     """
#     conn = sqlite3.connect(DB_PATH)
#     cur = conn.cursor()
#     rows = cur.execute("SELECT name, mode FROM strategies ORDER BY name ASC").fetchall()
#     conn.close()

#     data = [{"name": row[0], "mode": row[1]} for row in rows]
#     return jsonify({"success": True, "data": data})

@app.route('/api/strategies', methods=['GET'])
def get_all_strategies():
    """
    Returns all strategies with their columns (name, mode, allocation, tickers, stop_loss, take_profit).
    """
    conn = sqlite3.connect(DB_PATH)
    cur = conn.cursor()
    # UPDATED: selecting the new columns
    rows = cur.execute("""
        SELECT name, mode, allocation, tickers, stop_loss, take_profit
          FROM strategies
         ORDER BY name ASC
    """).fetchall()
    conn.close()

    data = []
    for row in rows:
        # tickers is stored as JSON text, so parse it
        t = []
        try:
            t = json.loads(row[3]) if row[3] else []
        except:
            pass

        data.append({
            'name': row[0],
            'mode': row[1],
            'allocation': row[2],
            'tickers': t,
            'stop_loss': row[4],
            'take_profit': row[5],
        })
    return jsonify({"success": True, "data": data})



@app.route('/api/strategies/<strategy_name>', methods=['PATCH'])
def update_strategy_mode(strategy_name):
    """
    Updates mode and optional fields: allocation, tickers, stop_loss, take_profit
    """
    payload = request.json
    new_mode = payload.get('mode', 'backtest')

    allocation = payload.get('allocation', 0.0)
    tickers = payload.get('tickers', [])
    stop_loss = payload.get('stop_loss', 0.0)
    take_profit = payload.get('take_profit', 0.0)

    if new_mode not in ['backtest','live']:
        return jsonify({"success": False, "message": "Invalid mode"}), 400

    # Convert tickers array to JSON string for DB
    tickers_str = json.dumps(tickers)

    conn = sqlite3.connect(DB_PATH)
    cur = conn.cursor()
    # UPDATED: now sets the new columns too
    cur.execute('''
        UPDATE strategies
           SET mode        = ?,
               allocation  = ?,
               tickers     = ?,
               stop_loss   = ?,
               take_profit = ?
         WHERE name        = ?
    ''', (
        new_mode, 
        allocation, 
        tickers_str, 
        stop_loss, 
        take_profit,
        strategy_name
    ))
    conn.commit()
    conn.close()

    return jsonify({
        "success": True,
        "message": f"{strategy_name} updated to {new_mode}",
        "data": {
            "allocation": allocation,
            "tickers": tickers,
            "stop_loss": stop_loss,
            "take_profit": take_profit
        }
    })








if __name__ == '__main__':
    initialize_app()
    app.run(host='0.0.0.0', port=5000, debug=True)
else:
    # Initialize the app when imported as a module
    initialize_app()

logger.debug(f"Flask backend starting with PID: {os.getpid()}")

